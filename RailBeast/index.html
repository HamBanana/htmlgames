<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Beast Busters</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            cursor: crosshair;
        }
        
        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            position: relative;
            z-index: 1;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        #ui > * {
            pointer-events: auto;
        }
        
        #hud {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            height: 80px;
            background: linear-gradient(to bottom, #000 0%, #111 50%, #000 100%);
            border: 3px solid #444;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 20px;
            color: #0f0;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 5px #0f0;
            pointer-events: none;
        }
        
        .hud-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .hud-label {
            font-size: 12px;
            color: #090;
            margin-bottom: 5px;
        }
        
        .hud-value {
            font-size: 20px;
            color: #0f0;
        }
        
        #health-bar {
            width: 150px;
            height: 20px;
            background: #222;
            border: 2px solid #444;
            border-radius: 10px;
            overflow: hidden;
        }
        
        #health-fill {
            height: 100%;
            background: linear-gradient(to right, #f00, #ff0);
            transition: width 0.3s;
        }
        
        #ammo-display {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .ammo-icon {
            width: 24px;
            height: 24px;
            background: #0f0;
            border-radius: 3px;
        }
        
        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            color: #ff0;
            text-shadow: 2px 2px 0 #000, 0 0 10px #ff0;
            pointer-events: none;
        }
        
        #weapon-select {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
        }
        
        .weapon-btn {
            width: 50px;
            height: 50px;
            background: #222;
            border: 3px solid #444;
            border-radius: 5px;
            color: #888;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .weapon-btn.active {
            border-color: #0f0;
            color: #0f0;
            box-shadow: 0 0 10px #0f0;
        }
        
        #crosshair {
            position: absolute;
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #f00;
            padding: 30px;
            text-align: center;
            display: none;
            color: #f00;
            font-size: 24px;
            border-radius: 10px;
            z-index: 100;
        }
        
        #gameOver h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #f00;
        }
        
        #gameOver button {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 20px;
            background: #f00;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        #gameOver button:hover {
            background: #ff0;
            transform: scale(1.1);
        }
        
        #instructions {
            position: absolute;
            top: 70px;
            left: 10px;
            color: #888;
            font-size: 12px;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            #hud {
                height: 60px;
                padding: 5px 10px;
            }
            
            .hud-label {
                font-size: 10px;
            }
            
            .hud-value {
                font-size: 16px;
            }
            
            #weapon-select {
                top: auto;
                bottom: 100px;
            }
            
            .weapon-btn {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
            
            #instructions {
                display: none;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="score">SCORE: 0</div>
        
        <div id="weapon-select">
            <div class="weapon-btn active" data-weapon="pistol">ðŸ”«</div>
            <div class="weapon-btn" data-weapon="machinegun">ðŸ”¥</div>
            <div class="weapon-btn" data-weapon="grenade">ðŸ’£</div>
        </div>
        
        <div id="instructions">
            MOUSE/TOUCH: Aim & Shoot<br>
            1-3: Change Weapon<br>
            SPACE: Quick Fire
        </div>
        
        <div id="hud">
            <div class="hud-section">
                <div class="hud-label">HEALTH</div>
                <div id="health-bar">
                    <div id="health-fill" style="width: 100%"></div>
                </div>
            </div>
            
            <div class="hud-section">
                <div class="hud-label">AMMO</div>
                <div id="ammo-display">
                    <div class="hud-value" id="ammo-count">âˆž</div>
                </div>
            </div>
            
            <div class="hud-section">
                <div class="hud-label">STAGE</div>
                <div class="hud-value" id="stage">1-1</div>
            </div>
        </div>
        
        <div id="crosshair">
            <svg width="40" height="40">
                <circle cx="20" cy="20" r="18" fill="none" stroke="#0f0" stroke-width="2" opacity="0.8"/>
                <line x1="20" y1="5" x2="20" y2="35" stroke="#0f0" stroke-width="2"/>
                <line x1="5" y1="20" x2="35" y2="20" stroke="#0f0" stroke-width="2"/>
                <circle cx="20" cy="20" r="3" fill="#f00"/>
            </svg>
        </div>
        
        <div id="gameOver">
            <h1>GAME OVER</h1>
            <div>Final Score: <span id="finalScore">0</span></div>
            <button id="continueBtn">CONTINUE?</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameRunning = true;
        let score = 0;
        let health = 100;
        let stage = 1;
        let substage = 1;
        let cameraX = 0;
        let cameraY = 0;
        let cameraZ = 0;
        let cameraShake = 0;
        let frameCount = 0;
        
        // Weapon system
        const weapons = {
            pistol: { damage: 25, fireRate: 5, ammo: Infinity, spread: 0, icon: 'ðŸ”«' },
            machinegun: { damage: 10, fireRate: 15, ammo: 200, spread: 0.1, icon: 'ðŸ”¥' },
            grenade: { damage: 100, fireRate: 1, ammo: 10, spread: 0, radius: 100, icon: 'ðŸ’£' }
        };
        let currentWeapon = 'pistol';
        let fireTimer = 0;
        let ammo = { machinegun: 200, grenade: 10 };
        
        // Input
        let mouseX = 0;
        let mouseY = 0;
        let mouseDown = false;
        let keys = {};
        
        // Entities
        let enemies = [];
        let projectiles = [];
        let particles = [];
        let pickups = [];
        
        // Rail movement
        let railTimer = 30; // Start at 30, will spawn first wave at 60
        let currentWaypoint = 0;
        let waveSpawned = false;
        
        // Enemy types
        const enemyTypes = {
            zombie: {
                health: 50,
                speed: 0.5,
                damage: 5,
                score: 100,
                size: 40,
                color: '#4a4',
                attackRange: 150
            },
            bat: {
                health: 25,
                speed: 1.5,
                damage: 3,
                score: 150,
                size: 30,
                color: '#822',
                flying: true,
                attackRange: 100
            },
            demon: {
                health: 100,
                speed: 1,
                damage: 10,
                score: 300,
                size: 60,
                color: '#f44',
                attackRange: 200
            },
            boss1: {
                health: 500,
                speed: 0.3,
                damage: 15,
                score: 1000,
                size: 80,
                color: '#f00',
                boss: true,
                attackRange: 250
            },
            boss2: {
                health: 800,
                speed: 0.5,
                damage: 20,
                score: 2000,
                size: 100,
                color: '#800',
                boss: true,
                attackRange: 300
            }
        };
        
        // Waves for each stage
        const waves = [
            ['zombie', 'zombie'],
            ['zombie', 'bat', 'zombie'],
            ['demon', 'zombie', 'bat'],
            ['boss1'],
            ['zombie', 'demon', 'zombie'],
            ['bat', 'bat', 'demon'],
            ['boss2']
        ];
        
        // Initialize
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Canvas input handlers
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);
            
            // Keyboard input
            document.addEventListener('keydown', (e) => keys[e.key] = true);
            document.addEventListener('keyup', (e) => keys[e.key] = false);
            
            // Weapon selection
            document.querySelectorAll('.weapon-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectWeapon(btn.dataset.weapon);
                });
            });
            
            // Continue button
            document.getElementById('continueBtn').addEventListener('click', () => {
                location.reload();
            });
            
            // Show crosshair
            document.getElementById('crosshair').style.display = 'block';
            
            // Update crosshair position
            document.addEventListener('mousemove', (e) => {
                const crosshair = document.getElementById('crosshair');
                crosshair.style.left = e.clientX - 20 + 'px';
                crosshair.style.top = e.clientY - 20 + 'px';
            });
            
            // Start with first wave ready to spawn
            railTimer = 30; // Will spawn at 60
            
            // Start game loop
            gameLoop();
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        }
        
        function handleMouseDown(e) {
            e.preventDefault();
            mouseDown = true;
        }
        
        function handleMouseUp(e) {
            e.preventDefault();
            mouseDown = false;
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            mouseDown = true;
            handleTouchMove(e);
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
            
            // Update crosshair for touch
            const crosshair = document.getElementById('crosshair');
            crosshair.style.display = 'block';
            crosshair.style.left = touch.clientX - 20 + 'px';
            crosshair.style.top = touch.clientY - 20 + 'px';
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            mouseDown = false;
        }
        
        function selectWeapon(weapon) {
            if (weapon === 'machinegun' && ammo.machinegun <= 0) return;
            if (weapon === 'grenade' && ammo.grenade <= 0) return;
            
            currentWeapon = weapon;
            document.querySelectorAll('.weapon-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.weapon === weapon);
            });
            updateAmmoDisplay();
        }
        
        function updateAmmoDisplay() {
            const ammoCount = document.getElementById('ammo-count');
            if (currentWeapon === 'pistol') {
                ammoCount.textContent = 'âˆž';
            } else {
                ammoCount.textContent = ammo[currentWeapon];
            }
        }
        
        // Game loop
        function gameLoop() {
            if (!gameRunning) return;
            
            update();
            render();
            requestAnimationFrame(gameLoop);
        }
        
        function update() {
            frameCount++;
            
            // Update camera shake
            if (cameraShake > 0) {
                cameraShake *= 0.9;
            }
            
            // Update rail movement
            updateRailMovement();
            
            // Weapon input
            handleWeaponInput();
            
            // Update entities
            updateProjectiles();
            updateEnemies();
            updateParticles();
            updatePickups();
            
            // Check game over
            if (health <= 0 && gameRunning) {
                gameOver();
            }
        }
        
        function updateRailMovement() {
            railTimer++;
            
            // Move between waypoints every 20 seconds (more time for combat)
            if (railTimer > 1200) {
                railTimer = 0;
                currentWaypoint++;
                waveSpawned = false;
                
                // Check if stage complete
                if (currentWaypoint >= waves.length) {
                    nextStage();
                }
            }
            
            // Spawn wave at beginning of each waypoint
            if (!waveSpawned && railTimer === 60) {
                waveSpawned = true;
                if (currentWaypoint < waves.length) {
                    spawnWave(currentWaypoint);
                }
            }
        }
        
        function spawnWave(waveIndex) {
            if (waveIndex >= waves.length) return;
            
            const enemyList = waves[waveIndex];
            enemyList.forEach((type, index) => {
                setTimeout(() => {
                    if (gameRunning) {
                        spawnEnemy(type);
                    }
                }, index * 500); // Spawn every 0.5 seconds
            });
        }
        
        function spawnEnemy(type) {
            const config = enemyTypes[type];
            
            // Spawn enemies within screen bounds
            const spawnMargin = 50;
            const maxX = Math.min(canvas.width / 3, 300);
            const maxY = Math.min(canvas.height / 4, 150);
            
            // Random position within bounds
            const x = (Math.random() - 0.5) * maxX * 2;
            const y = config.flying ? (Math.random() - 0.5) * maxY : 0;
            const z = -400 - Math.random() * 200; // Spawn in background
            
            enemies.push({
                type: type,
                x: x,
                y: y,
                z: z,
                health: config.health,
                maxHealth: config.health,
                speed: config.speed,
                damage: config.damage,
                score: config.score,
                size: config.size,
                color: config.color,
                boss: config.boss || false,
                flying: config.flying || false,
                attackRange: config.attackRange,
                attackTimer: 0,
                hitFlash: 0
            });
        }
        
        function handleWeaponInput() {
            // Keyboard weapon selection
            if (keys['1']) selectWeapon('pistol');
            if (keys['2']) selectWeapon('machinegun');
            if (keys['3']) selectWeapon('grenade');
            
            // Fire weapon
            if (fireTimer > 0) {
                fireTimer--;
            }
            
            if ((mouseDown || keys[' ']) && fireTimer === 0) {
                fireWeapon();
            }
        }
        
        function fireWeapon() {
            const weapon = weapons[currentWeapon];
            
            // Check ammo
            if (currentWeapon !== 'pistol' && ammo[currentWeapon] <= 0) {
                selectWeapon('pistol');
                return;
            }
            
            // Fire projectile
            fireTimer = 60 / weapon.fireRate;
            
            // Screen to world coordinates
            const aimX = (mouseX - canvas.width / 2);
            const aimY = (mouseY - canvas.height / 2);
            
            // Add spread
            const spreadX = (Math.random() - 0.5) * weapon.spread * 100;
            const spreadY = (Math.random() - 0.5) * weapon.spread * 100;
            
            if (currentWeapon === 'grenade') {
                projectiles.push({
                    type: 'grenade',
                    x: 0,
                    y: 0,
                    z: 0,
                    targetX: (aimX + spreadX) * 0.5,
                    targetY: (aimY + spreadY) * 0.5,
                    targetZ: -400,
                    speed: 10,
                    damage: weapon.damage,
                    radius: weapon.radius
                });
            } else {
                projectiles.push({
                    type: 'bullet',
                    x: 0,
                    y: 0,
                    z: 0,
                    vx: (aimX + spreadX) / 200,
                    vy: (aimY + spreadY) / 200,
                    vz: -20,
                    damage: weapon.damage,
                    color: currentWeapon === 'machinegun' ? '#ff0' : '#0f0'
                });
            }
            
            // Consume ammo
            if (currentWeapon !== 'pistol') {
                ammo[currentWeapon]--;
                updateAmmoDisplay();
            }
            
            // Muzzle flash
            createMuzzleFlash();
            
            // Camera shake
            cameraShake = currentWeapon === 'grenade' ? 10 : 3;
        }
        
        function updateProjectiles() {
            projectiles = projectiles.filter(proj => {
                if (proj.type === 'bullet') {
                    proj.x += proj.vx;
                    proj.y += proj.vy;
                    proj.z += proj.vz;
                    
                    // Check enemy hits
                    for (let enemy of enemies) {
                        const dx = proj.x - enemy.x;
                        const dy = proj.y - enemy.y;
                        const dz = proj.z - enemy.z;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        if (dist < enemy.size * 1.5) { // Slightly larger hit detection
                            damageEnemy(enemy, proj.damage);
                            createImpactEffect(enemy.x, enemy.y, enemy.z);
                            return false;
                        }
                    }
                    
                    return proj.z > -1000 && proj.z < 100;
                } else if (proj.type === 'grenade') {
                    // Move towards target
                    const dx = proj.targetX - proj.x;
                    const dy = proj.targetY - proj.y;
                    const dz = proj.targetZ - proj.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    if (dist < proj.speed) {
                        // Explode
                        createExplosion(proj.x, proj.y, proj.z, proj.radius);
                        
                        // Damage nearby enemies
                        enemies.forEach(enemy => {
                            const ex = enemy.x - proj.x;
                            const ey = enemy.y - proj.y;
                            const ez = enemy.z - proj.z;
                            const eDist = Math.sqrt(ex*ex + ey*ey + ez*ez);
                            
                            if (eDist < proj.radius * 2) { // Larger explosion radius
                                damageEnemy(enemy, proj.damage * (1 - eDist / (proj.radius * 2)));
                            }
                        });
                        
                        cameraShake = 20;
                        return false;
                    }
                    
                    proj.x += dx / dist * proj.speed;
                    proj.y += dy / dist * proj.speed;
                    proj.z += dz / dist * proj.speed;
                    
                    return true;
                }
            });
        }
        
        function updateEnemies() {
            enemies = enemies.filter(enemy => {
                // Update hit flash
                if (enemy.hitFlash > 0) {
                    enemy.hitFlash--;
                }
                
                // Move towards player
                const targetX = 0;
                const targetY = 0;
                const targetZ = -200; // Stay in mid-range
                
                const dx = targetX - enemy.x;
                const dy = targetY - enemy.y;
                const dz = targetZ - enemy.z;
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                if (dist > enemy.attackRange) {
                    enemy.x += dx / dist * enemy.speed;
                    enemy.y += dy / dist * enemy.speed;
                    enemy.z += dz / dist * enemy.speed;
                    
                    // Keep enemies within screen bounds
                    const maxX = Math.min(canvas.width / 3, 400);
                    const maxY = Math.min(canvas.height / 4, 200);
                    enemy.x = Math.max(-maxX, Math.min(maxX, enemy.x));
                    
                    if (!enemy.flying) {
                        enemy.y = 0;
                    } else {
                        enemy.y = Math.max(-maxY, Math.min(maxY, enemy.y));
                    }
                    
                    // Keep z in visible range
                    enemy.z = Math.max(-800, Math.min(-100, enemy.z));
                } else {
                    // Attack
                    enemy.attackTimer++;
                    if (enemy.attackTimer > 180) { // Attack every 3 seconds
                        enemy.attackTimer = 0;
                        takeDamage(enemy.damage);
                        createEnemyAttackEffect(enemy);
                    }
                }
                
                // Flying movement
                if (enemy.flying) {
                    enemy.y += Math.sin(frameCount * 0.05 + enemy.x) * 2;
                    // Keep flying enemies in bounds
                    const maxY = Math.min(canvas.height / 4, 200);
                    enemy.y = Math.max(-maxY, Math.min(maxY, enemy.y));
                }
                
                // Remove if dead
                if (enemy.health <= 0) {
                    return false;
                }
                
                return true;
            });
        }
        
        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.z += p.vz;
                p.vy += 0.5; // gravity
                p.life--;
                return p.life > 0;
            });
        }
        
        function updatePickups() {
            pickups = pickups.filter(pickup => {
                pickup.y += Math.sin(frameCount * 0.1) * 0.5;
                
                // Move pickup forward
                pickup.z += 2;
                
                // Check collection when close to screen
                if (pickup.z > -150) {
                    const dist = Math.sqrt(pickup.x * pickup.x + pickup.y * pickup.y);
                    if (dist < 100) {
                        collectPickup(pickup);
                        return false;
                    }
                }
                
                // Remove if past player
                return pickup.z < -50;
            });
        }
        
        function damageEnemy(enemy, damage) {
            enemy.health -= damage;
            enemy.hitFlash = 10;
            
            if (enemy.health <= 0) {
                score += enemy.score;
                updateScore();
                createDeathEffect(enemy);
                
                // Drop pickups at enemy location
                if (Math.random() < 0.4) { // 40% chance
                    // Ensure pickup is in a reasonable z range
                    const pickupZ = Math.max(-600, Math.min(-200, enemy.z));
                    dropPickup(enemy.x, enemy.y, pickupZ);
                }
                
                // Boss defeated
                if (enemy.boss) {
                    cameraShake = 30;
                }
            }
        }
        
        function takeDamage(amount) {
            health = Math.max(0, health - amount);
            document.getElementById('health-fill').style.width = health + '%';
            cameraShake = 15;
        }
        
        function dropPickup(x, y, z) {
            const types = ['health', 'machinegun', 'grenade'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            pickups.push({
                type: type,
                x: x,
                y: y,
                z: z,
                color: type === 'health' ? '#0f0' : '#ff0'
            });
        }
        
        function collectPickup(pickup) {
            switch (pickup.type) {
                case 'health':
                    health = Math.min(100, health + 35); // More health per pickup
                    document.getElementById('health-fill').style.width = health + '%';
                    break;
                case 'machinegun':
                    ammo.machinegun = Math.min(200, ammo.machinegun + 50);
                    break;
                case 'grenade':
                    ammo.grenade = Math.min(10, ammo.grenade + 3);
                    break;
            }
            updateAmmoDisplay();
        }
        
        // Visual effects
        function createMuzzleFlash() {
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: 0,
                    y: 0,
                    z: 0,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    vz: Math.random() * 5,
                    color: '#ff0',
                    size: 5,
                    life: 10
                });
            }
        }
        
        function createImpactEffect(x, y, z) {
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: x,
                    y: y,
                    z: z,
                    vx: (Math.random() - 0.5) * 20,
                    vy: (Math.random() - 0.5) * 20,
                    vz: (Math.random() - 0.5) * 20,
                    color: '#f00',
                    size: 3,
                    life: 20
                });
            }
        }
        
        function createExplosion(x, y, z, radius) {
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 30;
                particles.push({
                    x: x,
                    y: y,
                    z: z,
                    vx: Math.cos(angle) * speed,
                    vy: Math.random() * 30 - 15,
                    vz: Math.sin(angle) * speed,
                    color: ['#ff0', '#f80', '#f00'][Math.floor(Math.random() * 3)],
                    size: 10,
                    life: 30
                });
            }
        }
        
        function createDeathEffect(enemy) {
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: enemy.x,
                    y: enemy.y,
                    z: enemy.z,
                    vx: (Math.random() - 0.5) * 30,
                    vy: Math.random() * 20,
                    vz: (Math.random() - 0.5) * 30,
                    color: enemy.color,
                    size: 8,
                    life: 40
                });
            }
        }
        
        function createEnemyAttackEffect(enemy) {
            // Projectile towards player
            particles.push({
                x: enemy.x,
                y: enemy.y,
                z: enemy.z,
                vx: -enemy.x / 30,
                vy: -enemy.y / 30,
                vz: 10,
                color: '#f0f',
                size: 15,
                life: 30
            });
        }
        
        // Rendering
        function render() {
            // Clear with dark gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#000');
            gradient.addColorStop(0.5, '#111');
            gradient.addColorStop(1, '#000');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Apply camera shake
            ctx.save();
            if (cameraShake > 0) {
                ctx.translate(
                    (Math.random() - 0.5) * cameraShake,
                    (Math.random() - 0.5) * cameraShake
                );
            }
            
            // Draw background elements
            drawEnvironment();
            
            // Sort entities by depth
            const renderables = [
                ...enemies.map(e => ({ ...e, renderType: 'enemy' })),
                ...projectiles.map(p => ({ ...p, renderType: 'projectile' })),
                ...particles.map(p => ({ ...p, renderType: 'particle' })),
                ...pickups.map(p => ({ ...p, renderType: 'pickup' }))
            ].sort((a, b) => b.z - a.z);
            
            // Render all entities
            renderables.forEach(obj => {
                switch (obj.renderType) {
                    case 'enemy':
                        drawEnemy(obj);
                        break;
                    case 'projectile':
                        drawProjectile(obj);
                        break;
                    case 'particle':
                        drawParticle(obj);
                        break;
                    case 'pickup':
                        drawPickup(obj);
                        break;
                }
            });
            
            ctx.restore();
        }
        
        function drawEnvironment() {
            // Draw fog/mist
            for (let i = 0; i < 5; i++) {
                const alpha = 0.05 + Math.sin(frameCount * 0.01 + i) * 0.02;
                ctx.fillStyle = `rgba(128, 128, 128, ${alpha})`;
                ctx.fillRect(
                    0,
                    canvas.height * (0.6 + i * 0.1),
                    canvas.width,
                    canvas.height * 0.1
                );
            }
            
            // Draw ground grid
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.1)';
            ctx.lineWidth = 1;
            const gridSize = 80;
            const centerX = canvas.width / 2;
            const centerY = canvas.height * 0.7;
            
            // Vertical lines
            for (let x = -8; x <= 8; x++) {
                const screenX = centerX + x * gridSize;
                ctx.beginPath();
                ctx.moveTo(screenX, centerY);
                ctx.lineTo(screenX - x * 20, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines for depth
            for (let z = 0; z < 8; z++) {
                const y = centerY + z * z * 5;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        function drawEnemy(enemy) {
            // Skip enemies that are too close or too far
            if (enemy.z > -100 || enemy.z < -900) return;
            
            const screenPos = worldToScreen(enemy.x, enemy.y, enemy.z);
            if (!screenPos) return;
            
            const scale = screenPos.scale;
            const size = enemy.size * scale;
            
            // Skip if too large (too close)
            if (size > 200) return;
            
            // Hit flash
            if (enemy.hitFlash > 0) {
                ctx.fillStyle = '#fff';
            } else {
                ctx.fillStyle = enemy.color;
            }
            
            // Draw enemy sprite (simplified)
            ctx.save();
            ctx.translate(screenPos.x, screenPos.y);
            
            if (enemy.type === 'zombie') {
                // Body
                ctx.fillRect(-size/2, -size, size, size);
                // Head
                ctx.beginPath();
                ctx.arc(0, -size * 1.3, size * 0.3, 0, Math.PI * 2);
                ctx.fill();
                // Arms
                ctx.fillRect(-size * 0.8, -size * 0.7, size * 0.3, size * 0.5);
                ctx.fillRect(size * 0.5, -size * 0.7, size * 0.3, size * 0.5);
            } else if (enemy.type === 'bat') {
                // Wings
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-size, -size/2);
                ctx.lineTo(-size/2, -size);
                ctx.lineTo(0, -size/2);
                ctx.lineTo(size/2, -size);
                ctx.lineTo(size, -size/2);
                ctx.closePath();
                ctx.fill();
            } else if (enemy.type === 'demon' || enemy.boss) {
                // Horned creature
                ctx.fillRect(-size/2, -size, size, size);
                // Horns
                ctx.beginPath();
                ctx.moveTo(-size/3, -size);
                ctx.lineTo(-size/2, -size * 1.5);
                ctx.lineTo(-size/4, -size);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(size/3, -size);
                ctx.lineTo(size/2, -size * 1.5);
                ctx.lineTo(size/4, -size);
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#ff0';
                ctx.fillRect(-size/4, -size * 0.8, size/8, size/8);
                ctx.fillRect(size/8, -size * 0.8, size/8, size/8);
            }
            
            ctx.restore();
            
            // Health bar for bosses
            if (enemy.boss) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(screenPos.x - 50, screenPos.y - size * 2, 100, 10);
                ctx.fillStyle = '#f00';
                ctx.fillRect(screenPos.x - 50, screenPos.y - size * 2, 100 * (enemy.health / enemy.maxHealth), 10);
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(screenPos.x - 50, screenPos.y - size * 2, 100, 10);
            }
        }
        
        function drawProjectile(proj) {
            const screenPos = worldToScreen(proj.x, proj.y, proj.z);
            if (!screenPos) return;
            
            if (proj.type === 'bullet') {
                ctx.fillStyle = proj.color;
                ctx.fillRect(
                    screenPos.x - 2,
                    screenPos.y - 2,
                    4,
                    4
                );
                
                // Trail
                ctx.strokeStyle = proj.color;
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.moveTo(screenPos.x, screenPos.y);
                const trailPos = worldToScreen(proj.x - proj.vx * 3, proj.y - proj.vy * 3, proj.z - proj.vz * 3);
                if (trailPos) {
                    ctx.lineTo(trailPos.x, trailPos.y);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            } else if (proj.type === 'grenade') {
                ctx.fillStyle = '#080';
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, 8 * screenPos.scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#0f0';
                ctx.stroke();
            }
        }
        
        function drawParticle(p) {
            const screenPos = worldToScreen(p.x, p.y, p.z);
            if (!screenPos) return;
            
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life / 40;
            ctx.fillRect(
                screenPos.x - p.size/2 * screenPos.scale,
                screenPos.y - p.size/2 * screenPos.scale,
                p.size * screenPos.scale,
                p.size * screenPos.scale
            );
            ctx.globalAlpha = 1;
        }
        
        function drawPickup(pickup) {
            const screenPos = worldToScreen(pickup.x, pickup.y, pickup.z);
            if (!screenPos) return;
            
            const size = 20 * screenPos.scale;
            
            ctx.fillStyle = pickup.color;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            
            if (pickup.type === 'health') {
                // Draw cross
                ctx.fillRect(screenPos.x - size/2, screenPos.y - size/6, size, size/3);
                ctx.fillRect(screenPos.x - size/6, screenPos.y - size/2, size/3, size);
            } else {
                // Draw box
                ctx.fillRect(screenPos.x - size/2, screenPos.y - size/2, size, size);
                ctx.strokeRect(screenPos.x - size/2, screenPos.y - size/2, size, size);
            }
            
            // Glow effect
            ctx.strokeStyle = pickup.color;
            ctx.globalAlpha = 0.3 + Math.sin(frameCount * 0.1) * 0.2;
            ctx.strokeRect(screenPos.x - size, screenPos.y - size, size * 2, size * 2);
            ctx.globalAlpha = 1;
        }
        
        function worldToScreen(x, y, z) {
            // Simple perspective projection
            const fov = 1000; // Further increased FOV for wider view
            if (z >= -50) return null; // Too close
            if (z < -1000) return null; // Too far
            
            const scale = fov / -z;
            const screenX = canvas.width / 2 + x * scale;
            const screenY = canvas.height / 2 - y * scale;
            
            // Don't render if outside screen bounds
            const margin = 100;
            if (screenX < -margin || screenX > canvas.width + margin ||
                screenY < -margin || screenY > canvas.height + margin) {
                return null;
            }
            
            return { x: screenX, y: screenY, scale: scale };
        }
        
        function nextStage() {
            substage++;
            if (substage > 2) {
                stage++;
                substage = 1;
            }
            
            document.getElementById('stage').textContent = `${stage}-${substage}`;
            
            // Clear remaining enemies
            enemies = [];
            
            // Reset for next stage
            currentWaypoint = 0;
            railTimer = 30; // Will spawn at 60
            waveSpawned = false;
            
            // Increase difficulty
            Object.values(enemyTypes).forEach(type => {
                type.health *= 1.2;
                type.speed = Math.min(type.speed * 1.1, 5); // Cap speed
                type.damage *= 1.1;
            });
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `SCORE: ${score}`;
        }
        
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        // Start game
        init();
    </script>
</body>
</html>