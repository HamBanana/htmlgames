<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pacman - GameFramework</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        
        #gameContainer {
            position: relative;
            border: 2px solid #00f;
            box-shadow: 0 0 20px #00f;
        }
        
        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            color: #fff;
            font-size: 18px;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f00;
            font-size: 48px;
            font-weight: bold;
            text-align: center;
            display: none;
            text-shadow: 3px 3px 0 #000;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="ui-overlay">
            <div>SCORE: <span id="score">0</span></div>
            <div>LIVES: <span id="lives">3</span></div>
        </div>
        <div class="game-over" id="gameOver">
            GAME OVER<br>
            <span style="font-size: 24px">PRESS SPACE TO RESTART</span>
        </div>
        <div class="loading" id="loadingText">Loading GameFramework...</div>
    </div>

    <!-- Load GameFramework -->
    <script src="../GameFramework/index.js" type="module"></script>
    
    <!-- Pacman Game Code -->
    <script type="module">
        // Import needed for manual asset loading
        let GameFramework = null;
        
        // Wait for framework to load
        window.addEventListener('gameframework:ready', async (event) => {
            GameFramework = event.detail.framework;
            
            // Game Constants
            const TILE_SIZE = 32;
            const MAZE_WIDTH = 19;
            const MAZE_HEIGHT = 21;
            const GHOST_COUNT = 4;
            
            // Maze layout (1 = wall, 0 = pellet, 2 = power pellet, 3 = empty)
            const MAZE = [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
                [1,2,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,2,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
                [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
                [1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1],
                [3,3,3,1,0,1,0,0,0,0,0,0,0,1,0,1,3,3,3],
                [1,1,1,1,0,1,0,1,1,3,1,1,0,1,0,1,1,1,1],
                [0,0,0,0,0,0,0,1,3,3,3,1,0,0,0,0,0,0,0],
                [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
                [3,3,3,1,0,1,0,0,0,0,0,0,0,1,0,1,3,3,3],
                [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
                [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
                [1,2,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,2,1],
                [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
                [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
                [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ];
            
            // Create Pacman Component (without render method to let sprite handle rendering)
            class PacmanController extends GameFramework.Component {
                constructor() {
                    super();
                    this.speed = 150;
                    this.direction = { x: 0, y: 0 };
                    this.nextDirection = { x: 0, y: 0 };
                    this.gridX = 9;
                    this.gridY = 15;
                    this.animTimer = 0;
                    this.mouthOpen = true;
                }
                
                start() {
                    // Center on starting grid position
                    this.entity.position.x = this.gridX * TILE_SIZE + TILE_SIZE / 2;
                    this.entity.position.y = this.gridY * TILE_SIZE + TILE_SIZE / 2;
                    console.log('Pacman started at:', this.entity.position);
                    
                    // Start moving left by default
                    this.direction = { x: -1, y: 0 };
                    this.nextDirection = { x: -1, y: 0 };
                }
                
                update(deltaTime) {
                    if (!this.enabled) return;
                    
                    const input = this.engine.input;
                    const scene = this.scene;
                    const animSprite = this.getComponent(GameFramework.Components.AnimatedSprite);
                    
                    // Handle input - use isKeyPressed for continuous movement
                    if (input.isKeyPressed('ArrowLeft') || input.isKeyPressed('KeyA')) {
                        this.nextDirection = { x: -1, y: 0 };
                    } else if (input.isKeyPressed('ArrowRight') || input.isKeyPressed('KeyD')) {
                        this.nextDirection = { x: 1, y: 0 };
                    } else if (input.isKeyPressed('ArrowUp') || input.isKeyPressed('KeyW')) {
                        this.nextDirection = { x: 0, y: -1 };
                    } else if (input.isKeyPressed('ArrowDown') || input.isKeyPressed('KeyS')) {
                        this.nextDirection = { x: 0, y: 1 };
                    }
                    
                    // Get current grid position
                    const currentGridX = Math.floor(this.entity.position.x / TILE_SIZE);
                    const currentGridY = Math.floor(this.entity.position.y / TILE_SIZE);
                    
                    // Try to apply next direction
                    if (this.nextDirection.x !== 0 || this.nextDirection.y !== 0) {
                        const testX = currentGridX + this.nextDirection.x;
                        const testY = currentGridY + this.nextDirection.y;
                        
                        if (this.canMoveTo(testX, testY)) {
                            this.direction = { ...this.nextDirection };
                        }
                    }
                    
                    // Always try to move in current direction
                    if (this.direction.x !== 0 || this.direction.y !== 0) {
                        const moveSpeed = this.speed * deltaTime;
                        const newX = this.entity.position.x + this.direction.x * moveSpeed;
                        const newY = this.entity.position.y + this.direction.y * moveSpeed;
                        
                        // Simple collision check - just check the grid we're moving into
                        const checkGridX = Math.floor(newX / TILE_SIZE);
                        const checkGridY = Math.floor(newY / TILE_SIZE);
                        
                        if (this.canMoveTo(checkGridX, checkGridY)) {
                            this.entity.position.x = newX;
                            this.entity.position.y = newY;
                            
                            // Update sprite direction and animation
                            if (animSprite) {
                                animSprite.flipX = this.direction.x < 0;
                                
                                // Play appropriate animation
                                if (this.direction.x !== 0 || this.direction.y !== 0) {
                                    if (!animSprite.playing || animSprite.getCurrentAnimation() !== 'walk') {
                                        animSprite.playFirstAvailable('walk', 'run', 'idle');
                                    }
                                } else {
                                    if (!animSprite.playing || animSprite.getCurrentAnimation() !== 'idle') {
                                        animSprite.play('idle');
                                    }
                                }
                            }
                        } else {
                            // Stopped, play idle
                            if (animSprite && (!animSprite.playing || animSprite.getCurrentAnimation() !== 'idle')) {
                                animSprite.play('idle');
                            }
                        }
                    }
                    
                    // Update current grid position for pellet collection
                    this.gridX = Math.round((this.entity.position.x - TILE_SIZE / 2) / TILE_SIZE);
                    this.gridY = Math.round((this.entity.position.y - TILE_SIZE / 2) / TILE_SIZE);
                    
                    // Collect pellets
                    if (scene.maze[this.gridY] && scene.maze[this.gridY][this.gridX] === 0) {
                        scene.maze[this.gridY][this.gridX] = 3; // Empty
                        scene.score += 10;
                        scene.pelletsRemaining--;
                        document.getElementById('score').textContent = scene.score;
                        
                        if (scene.pelletsRemaining === 0) {
                            scene.gameWon();
                        }
                    } else if (scene.maze[this.gridY] && scene.maze[this.gridY][this.gridX] === 2) {
                        scene.maze[this.gridY][this.gridX] = 3; // Empty
                        scene.score += 50;
                        scene.pelletsRemaining--;
                        scene.activatePowerMode();
                        document.getElementById('score').textContent = scene.score;
                    }
                }
                
                canMoveTo(x, y) {
                    // Check bounds
                    if (x < 0 || x >= MAZE_WIDTH || y < 0 || y >= MAZE_HEIGHT) {
                        return false;
                    }
                    // Check if it's a wall  
                    const scene = this.entity ? this.entity.scene : null;
                    if (!scene || !scene.maze || !scene.maze[y]) {
                        return true; // Allow movement if scene not ready
                    }
                    return scene.maze[y][x] !== 1;
                }
                
                // No render method - let the sprite components handle rendering
            }
            
            // Ghost AI Component
            class GhostAI extends GameFramework.Component {
                constructor(color, startX, startY) {
                    super();
                    this.color = color;
                    this.speed = 100;
                    this.gridX = startX;
                    this.gridY = startY;
                    this.direction = { x: 0, y: -1 };
                    this.state = 'scatter'; // scatter, chase, frightened
                    this.frightenedTimer = 0;
                    this.animTimer = 0;
                    this.animFrame = 0;
                }
                
                start() {
                    this.entity.position.x = this.gridX * TILE_SIZE + TILE_SIZE / 2;
                    this.entity.position.y = this.gridY * TILE_SIZE + TILE_SIZE / 2;
                }
                
                update(deltaTime) {
                    const scene = this.scene;
                    const pacman = scene.pacman;
                    
                    // Update frightened state
                    if (this.state === 'frightened') {
                        this.frightenedTimer -= deltaTime;
                        if (this.frightenedTimer <= 0) {
                            this.state = 'chase';
                        }
                    }
                    
                    // Get current grid position
                    const currentGridX = Math.round((this.entity.position.x - TILE_SIZE / 2) / TILE_SIZE);
                    const currentGridY = Math.round((this.entity.position.y - TILE_SIZE / 2) / TILE_SIZE);
                    
                    // At intersection, choose new direction
                    if (Math.abs(this.entity.position.x - (currentGridX * TILE_SIZE + TILE_SIZE / 2)) < 2 &&
                        Math.abs(this.entity.position.y - (currentGridY * TILE_SIZE + TILE_SIZE / 2)) < 2) {
                        
                        const possibleDirs = [];
                        const dirs = [
                            { x: 0, y: -1 }, // up
                            { x: 1, y: 0 },  // right
                            { x: 0, y: 1 },  // down
                            { x: -1, y: 0 }  // left
                        ];
                        
                        // Don't reverse direction unless frightened
                        dirs.forEach(dir => {
                            if (this.state !== 'frightened' && 
                                dir.x === -this.direction.x && dir.y === -this.direction.y) {
                                return; // Skip reverse
                            }
                            
                            const nextX = currentGridX + dir.x;
                            const nextY = currentGridY + dir.y;
                            
                            if (this.canMoveTo(nextX, nextY)) {
                                possibleDirs.push(dir);
                            }
                        });
                        
                        if (possibleDirs.length > 0) {
                            if (this.state === 'frightened') {
                                // Random direction when frightened
                                this.direction = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                            } else if (this.state === 'chase' && pacman) {
                                // Chase Pacman
                                const pacmanGridX = Math.round((pacman.position.x - TILE_SIZE / 2) / TILE_SIZE);
                                const pacmanGridY = Math.round((pacman.position.y - TILE_SIZE / 2) / TILE_SIZE);
                                
                                let bestDir = possibleDirs[0];
                                let bestDist = Infinity;
                                
                                possibleDirs.forEach(dir => {
                                    const nextX = currentGridX + dir.x;
                                    const nextY = currentGridY + dir.y;
                                    const dist = Math.abs(nextX - pacmanGridX) + Math.abs(nextY - pacmanGridY);
                                    
                                    if (dist < bestDist) {
                                        bestDist = dist;
                                        bestDir = dir;
                                    }
                                });
                                
                                this.direction = bestDir;
                            } else {
                                // Scatter mode - random
                                this.direction = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                            }
                        }
                    }
                    
                    // Move ghost
                    const speed = this.state === 'frightened' ? this.speed * 0.5 : this.speed;
                    this.entity.position.x += this.direction.x * speed * deltaTime;
                    this.entity.position.y += this.direction.y * speed * deltaTime;
                    
                    // Check collision with Pacman
                    if (pacman) {
                        const dist = this.entity.position.distanceTo(pacman.position);
                        if (dist < 20) {
                            if (this.state === 'frightened') {
                                // Ghost eaten
                                scene.score += 200;
                                document.getElementById('score').textContent = scene.score;
                                // Reset ghost
                                this.gridX = 9;
                                this.gridY = 9;
                                this.entity.position.x = this.gridX * TILE_SIZE + TILE_SIZE / 2;
                                this.entity.position.y = this.gridY * TILE_SIZE + TILE_SIZE / 2;
                                this.state = 'scatter';
                            } else {
                                // Pacman caught
                                scene.loseLife();
                            }
                        }
                    }
                    
                    // Animate
                    this.animTimer += deltaTime;
                    if (this.animTimer > 0.2) {
                        this.animFrame = (this.animFrame + 1) % 2;
                        this.animTimer = 0;
                    }
                }
                
                canMoveTo(x, y) {
                    // Check bounds
                    if (x < 0 || x >= MAZE_WIDTH || y < 0 || y >= MAZE_HEIGHT) {
                        return false;
                    }
                    // Check if it's a wall
                    const scene = this.entity ? this.entity.scene : null;
                    if (!scene || !scene.maze || !scene.maze[y]) {
                        return true; // Allow movement if scene not ready
                    }
                    return scene.maze[y][x] !== 1;
                }
                
                setFrightened() {
                    this.state = 'frightened';
                    this.frightenedTimer = 8;
                }
                
                render(context) {
                    // Ghost body
                    context.fillStyle = this.state === 'frightened' ? '#0000ff' : this.color;
                    context.beginPath();
                    context.arc(0, -4, 12, Math.PI, 0);
                    context.lineTo(12, 8);
                    
                    // Wavy bottom
                    for (let i = 0; i < 4; i++) {
                        const x = 12 - (i * 8);
                        const y = 8 + (this.animFrame === 0 ? 2 : -2) * (i % 2 === 0 ? 1 : -1);
                        context.lineTo(x, y);
                    }
                    
                    context.closePath();
                    context.fill();
                    
                    // Eyes
                    context.fillStyle = '#ffffff';
                    context.beginPath();
                    context.arc(-5, -4, 3, 0, Math.PI * 2);
                    context.arc(5, -4, 3, 0, Math.PI * 2);
                    context.fill();
                    
                    // Pupils
                    context.fillStyle = this.state === 'frightened' ? '#ffffff' : '#000000';
                    context.beginPath();
                    context.arc(-5 + this.direction.x * 2, -4 + this.direction.y * 2, 1.5, 0, Math.PI * 2);
                    context.arc(5 + this.direction.x * 2, -4 + this.direction.y * 2, 1.5, 0, Math.PI * 2);
                    context.fill();
                }
            }
            
            // Game Scene
            class PacmanScene extends GameFramework.Scene {
                constructor() {
                    super('pacman', {
                        backgroundColor: '#000000'
                    });
                    
                    this.maze = [];
                    this.score = 0;
                    this.lives = 3;
                    this.pelletsRemaining = 0;
                    this.powerMode = false;
                    this.powerTimer = 0;
                    this.pacman = null;
                    this.ghosts = [];
                }
                
                async onLoad() {
                    document.getElementById('loadingText').textContent = 'Loading assets...';
                    
                    // Load karateguy sprite - it's a framework asset
                    try {
                        // Try multiple possible locations for the karateguy sprite
                        const possiblePaths = [
                            // Framework assets location
                            { json: '/GameAssets/Sprites/Aseprite/karateguy.json', png: '/GameAssets/Sprites/Aseprite/karateguy.png' },
                            // Local assets
                            { json: 'assets/sprites/karateguy.json', png: 'assets/sprites/karateguy.png' },
                            // Root directory
                            { json: 'karateguy.json', png: 'karateguy.png' }
                        ];
                        
                        let loaded = false;
                        
                        for (const paths of possiblePaths) {
                            try {
                                console.log(`Trying to load karateguy from: ${paths.json}`);
                                
                                // Load the JSON data
                                const response = await fetch(paths.json);
                                if (!response.ok) continue;
                                
                                const jsonData = await response.json();
                                console.log('JSON loaded successfully');
                                
                                // Fix the empty image field if needed
                                if (jsonData.meta && jsonData.meta.image === '') {
                                    jsonData.meta.image = paths.png;
                                }
                                
                                // Ensure frameTags is properly parsed
                                if (jsonData.meta && typeof jsonData.meta.frameTags === 'string') {
                                    try {
                                        jsonData.meta.frameTags = JSON.parse(jsonData.meta.frameTags.replace(/\\/g, ''));
                                    } catch (e) {
                                        console.error('Failed to parse frameTags');
                                    }
                                }
                                
                                // Parse the data using AsepriteParser
                                const parsed = await GameFramework.Parsers.AsepriteParser.parse(jsonData);
                                
                                // Load the PNG image
                                const image = await new Promise((resolve, reject) => {
                                    const img = new Image();
                                    img.onload = () => {
                                        console.log(`PNG loaded successfully from: ${paths.png}`);
                                        resolve(img);
                                    };
                                    img.onerror = () => reject(new Error(`Failed to load ${paths.png}`));
                                    img.src = paths.png;
                                });
                                
                                // Store in renderer with proper frame structure
                                const renderer = this.engine.renderer;
                                if (renderer && image) {
                                    renderer.sprites.set('karateguy', image);
                                    
                                    // Debug: log the parsed data structure
                                    console.log('Parsed frames:', parsed.frames);
                                    console.log('Parsed animations:', parsed.animations);
                                    
                                    // Ensure frames are accessible
                                    if (!parsed.frames || parsed.frames.size === 0) {
                                        console.error('No frames found in parsed data');
                                        
                                        // If frames is an object, convert to Map
                                        if (jsonData.frames && typeof jsonData.frames === 'object') {
                                            parsed.frames = new Map();
                                            Object.entries(jsonData.frames).forEach(([key, value]) => {
                                                parsed.frames.set(key, value);
                                            });
                                            console.log('Converted frames to Map:', parsed.frames);
                                        }
                                    }
                                    
                                    renderer.spriteData.set('karateguy', parsed);
                                    
                                    // Also store in assets
                                    this.engine.assets.assets.set('karateguy', {
                                        type: 'aseprite',
                                        data: { image, ...parsed },
                                        name: 'karateguy'
                                    });
                                    
                                    console.log('Karateguy sprite loaded and registered successfully');
                                    console.log('Image dimensions:', image.width, 'x', image.height);
                                    console.log('First frame:', parsed.frames.get('0') || parsed.frames.get('1') || 'No frame 0 or 1');
                                    loaded = true;
                                    break;
                                }
                            } catch (e) {
                                console.log(`Failed to load from ${paths.json}:`, e.message);
                            }
                        }
                        
                        if (!loaded) {
                            console.warn('Could not load karateguy sprite from any location');
                        }
                        
                    } catch (error) {
                        console.error('Failed to load karateguy sprite:', error);
                    }
                    
                    document.getElementById('loadingText').style.display = 'none';
                    
                    // Initialize maze
                    this.initializeMaze();
                    
                    // Create Pacman
                    this.createPacman();
                    
                    // Create ghosts
                    this.createGhosts();
                    
                    // Create maze walls
                    this.createMazeWalls();
                }
                
                initializeMaze() {
                    // Deep copy maze and count pellets
                    this.maze = MAZE.map(row => [...row]);
                    this.pelletsRemaining = 0;
                    
                    for (let y = 0; y < MAZE_HEIGHT; y++) {
                        for (let x = 0; x < MAZE_WIDTH; x++) {
                            if (this.maze[y][x] === 0 || this.maze[y][x] === 2) {
                                this.pelletsRemaining++;
                            }
                        }
                    }
                }
                
                createPacman() {
                    const pacman = new GameFramework.Entity({
                        name: 'Pacman',
                        x: 0,
                        y: 0,
                        layer: 2
                    });
                    
                    // Add PacmanController first
                    const controller = new PacmanController();
                    pacman.addComponent(controller);
                    
                    // Check if we have the karateguy sprite
                    if (this.engine.assets.has('karateguy')) {
                        console.log('Karateguy asset found in assets manager');
                        
                        // Debug: Check what's in the renderer
                        const sprite = this.engine.renderer.getSprite('karateguy');
                        const spriteData = this.engine.renderer.getSpriteData('karateguy');
                        console.log('Sprite image:', sprite);
                        console.log('Sprite data:', spriteData);
                        
                        if (sprite && spriteData) {
                            // Create a simple sprite renderer that directly uses the image
                            const simpleRenderer = new GameFramework.Component();
                            simpleRenderer.sprite = sprite;
                            simpleRenderer.spriteData = spriteData;
                            simpleRenderer.currentFrame = 0;
                            simpleRenderer.animTimer = 0;
                            
                            simpleRenderer.render = function(context) {
                                if (!this.sprite) return;
                                
                                // For simplicity, just draw a portion of the sprite sheet
                                // Assuming the sprite sheet has frames arranged in a grid
                                const frameWidth = 32;  // Typical frame width
                                const frameHeight = 64; // Typical frame height
                                
                                // Calculate frame position (simple animation)
                                const framesPerRow = Math.floor(this.sprite.width / frameWidth);
                                const frameX = (this.currentFrame % framesPerRow) * frameWidth;
                                const frameY = Math.floor(this.currentFrame / framesPerRow) * frameHeight;
                                
                                // Draw the sprite frame
                                try {
                                    context.drawImage(
                                        this.sprite,
                                        frameX, frameY, frameWidth, frameHeight,  // Source
                                        -frameWidth/2, -frameHeight/2, frameWidth, frameHeight  // Destination
                                    );
                                } catch (e) {
                                    console.error('Error drawing sprite:', e);
                                    // Fallback to yellow circle
                                    context.fillStyle = '#ffff00';
                                    context.beginPath();
                                    context.arc(0, 0, 12, 0, 2 * Math.PI);
                                    context.fill();
                                }
                            };
                            
                            simpleRenderer.update = function(deltaTime) {
                                // Simple animation cycling
                                this.animTimer += deltaTime;
                                if (this.animTimer > 0.1) {
                                    this.currentFrame = (this.currentFrame + 1) % 10; // Assume max 10 frames
                                    this.animTimer = 0;
                                }
                            };
                            
                            pacman.addComponent(simpleRenderer);
                            
                            // Scale down the sprite to fit the tile size
                            pacman.scaleX = 0.75;
                            pacman.scaleY = 0.375;
                            
                            console.log('Using simple renderer for karateguy sprite');
                            
                            // Also try the original AsepriteRenderer approach
                            /*
                            const renderer = new GameFramework.Components.AsepriteRenderer('karateguy');
                            pacman.addComponent(renderer);
                            
                            // Manually trigger sprite loading since it might not happen in start()
                            if (!renderer.sprite || !renderer.spriteData) {
                                renderer.loadSprite();
                            }
                            
                            // Check if it's animated and add animation component
                            if (spriteData.animations && spriteData.animations.size > 0) {
                                const animSprite = new GameFramework.Components.AnimatedSprite('karateguy');
                                pacman.addComponent(animSprite);
                                
                                console.log('Available animations:', animSprite.getAnimationNames());
                                
                                // Try to play idle animation
                                if (animSprite.hasAnimation('idle')) {
                                    animSprite.play('idle');
                                    console.log('Playing idle animation');
                                } else if (animSprite.hasAnimation('Idle')) {
                                    animSprite.play('Idle');
                                    console.log('Playing Idle animation');
                                } else {
                                    // Play first available animation
                                    const anims = animSprite.getAnimationNames();
                                    if (anims.length > 0) {
                                        animSprite.play(anims[0]);
                                        console.log('Playing first available animation:', anims[0]);
                                    }
                                }
                            } else {
                                console.log('No animations found in sprite data');
                            }
                            */
                            
                            // Add a debug component to check rendering
                            const debugComponent = new GameFramework.Component();
                            debugComponent.firstRender = true;
                            debugComponent.render = function(context) {
                                if (this.firstRender) {
                                    console.log('Debug render called');
                                    console.log('Entity position:', this.entity.position);
                                    console.log('Entity scale:', this.entity.scale);
                                    this.firstRender = false;
                                }
                                
                                // Draw a debug outline
                                context.strokeStyle = '#00ff00';
                                context.lineWidth = 1;
                                context.strokeRect(-16, -16, 32, 32);
                            };
                            pacman.addComponent(debugComponent);
                        } else {
                            console.error('Sprite or sprite data missing from renderer');
                        }
                    } else {
                        // Fallback to simple yellow circle
                        console.log('Karateguy not found in assets, using fallback');
                        const fallbackRenderer = new GameFramework.Component();
                        fallbackRenderer.render = function(context) {
                            context.fillStyle = '#ffff00';
                            context.beginPath();
                            context.arc(0, 0, 12, 0, 2 * Math.PI);
                            context.fill();
                        };
                        pacman.addComponent(fallbackRenderer);
                    }
                    
                    this.addEntity(pacman);
                    this.pacman = pacman;
                    
                    console.log('Pacman created at position:', pacman.position);
                    console.log('Pacman components:', Array.from(pacman.components.keys()).map(c => c.name));
                }
                
                createGhosts() {
                    const ghostColors = ['#ff0000', '#00ffff', '#ffb8ff', '#ffb852'];
                    const ghostPositions = [
                        { x: 9, y: 9 },
                        { x: 8, y: 9 },
                        { x: 10, y: 9 },
                        { x: 9, y: 10 }
                    ];
                    
                    for (let i = 0; i < GHOST_COUNT; i++) {
                        const ghost = new GameFramework.Entity({
                            name: `Ghost${i}`,
                            x: 0,
                            y: 0,
                            layer: 2
                        });
                        
                        ghost.addComponent(new GhostAI(
                            ghostColors[i],
                            ghostPositions[i].x,
                            ghostPositions[i].y
                        ));
                        
                        this.addEntity(ghost);
                        this.ghosts.push(ghost);
                    }
                }
                
                createMazeWalls() {
                    // Create visual maze representation
                    const mazeEntity = new GameFramework.Entity({
                        name: 'Maze',
                        x: 0,
                        y: 0,
                        layer: 0
                    });
                    
                    const mazeRenderer = new GameFramework.Component();
                    mazeRenderer.render = function(context) {
                        const scene = this.scene;
                        
                        // Draw maze
                        for (let y = 0; y < MAZE_HEIGHT; y++) {
                            for (let x = 0; x < MAZE_WIDTH; x++) {
                                const tile = scene.maze[y][x];
                                const px = x * TILE_SIZE;
                                const py = y * TILE_SIZE;
                                
                                if (tile === 1) {
                                    // Wall
                                    context.fillStyle = '#0000ff';
                                    context.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                                    
                                    // Inner border
                                    context.strokeStyle = '#4040ff';
                                    context.lineWidth = 2;
                                    context.strokeRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                                } else if (tile === 0) {
                                    // Pellet
                                    context.fillStyle = '#ffff00';
                                    context.beginPath();
                                    context.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, 3, 0, Math.PI * 2);
                                    context.fill();
                                } else if (tile === 2) {
                                    // Power pellet
                                    context.fillStyle = '#ffff00';
                                    context.beginPath();
                                    context.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, 8, 0, Math.PI * 2);
                                    context.fill();
                                }
                            }
                        }
                    };
                    
                    mazeEntity.addComponent(mazeRenderer);
                    this.addEntity(mazeEntity);
                }
                
                onActivate() {
                    // Reset score and lives display
                    document.getElementById('score').textContent = this.score;
                    document.getElementById('lives').textContent = this.lives;
                    
                    // Create a game logic entity to handle scene updates
                    const gameLogic = new GameFramework.Entity({
                        name: 'GameLogic',
                        x: 0,
                        y: 0
                    });
                    
                    const logicComponent = new GameFramework.Component();
                    logicComponent.update = (deltaTime) => {
                        // Update power mode
                        if (this.powerMode) {
                            this.powerTimer -= deltaTime;
                            if (this.powerTimer <= 0) {
                                this.powerMode = false;
                                // Reset ghost states
                                this.ghosts.forEach(ghost => {
                                    const ai = ghost.getComponent(GhostAI);
                                    if (ai) ai.state = 'chase';
                                });
                            }
                        }
                    };
                    
                    gameLogic.addComponent(logicComponent);
                    this.addEntity(gameLogic);
                }
                
                activatePowerMode() {
                    this.powerMode = true;
                    this.powerTimer = 8;
                    
                    // Make ghosts frightened
                    this.ghosts.forEach(ghost => {
                        const ai = ghost.getComponent(GhostAI);
                        if (ai) ai.setFrightened();
                    });
                }
                
                loseLife() {
                    this.lives--;
                    document.getElementById('lives').textContent = this.lives;
                    
                    if (this.lives <= 0) {
                        this.gameOver();
                    } else {
                        // Reset positions
                        const pacmanController = this.pacman.getComponent(PacmanController);
                        pacmanController.gridX = 9;
                        pacmanController.gridY = 15;
                        pacmanController.direction = { x: 0, y: 0 };
                        this.pacman.position.x = pacmanController.gridX * TILE_SIZE + TILE_SIZE / 2;
                        this.pacman.position.y = pacmanController.gridY * TILE_SIZE + TILE_SIZE / 2;
                        
                        // Reset ghosts
                        const ghostPositions = [
                            { x: 9, y: 9 },
                            { x: 8, y: 9 },
                            { x: 10, y: 9 },
                            { x: 9, y: 10 }
                        ];
                        
                        this.ghosts.forEach((ghost, i) => {
                            const ai = ghost.getComponent(GhostAI);
                            ai.gridX = ghostPositions[i].x;
                            ai.gridY = ghostPositions[i].y;
                            ghost.position.x = ai.gridX * TILE_SIZE + TILE_SIZE / 2;
                            ghost.position.y = ai.gridY * TILE_SIZE + TILE_SIZE / 2;
                            ai.state = 'scatter';
                        });
                    }
                }
                
                gameOver() {
                    this.engine.pause();
                    document.getElementById('gameOver').style.display = 'block';
                }
                
                gameWon() {
                    // Reset level with bonus
                    this.score += 1000;
                    document.getElementById('score').textContent = this.score;
                    this.initializeMaze();
                    
                    // Increase difficulty
                    this.ghosts.forEach(ghost => {
                        const ai = ghost.getComponent(GhostAI);
                        ai.speed = Math.min(ai.speed * 1.1, 180);
                    });
                }
            }
            
            // Initialize game
            try {
                const game = await GameFramework.quickStart('gameCanvas', {
                    width: MAZE_WIDTH * TILE_SIZE,
                    height: MAZE_HEIGHT * TILE_SIZE,
                    backgroundColor: '#000000',
                    smoothing: false,
                    debug: false  // Set to true to see debug info
                });
                
                console.log('Game engine created');
                
                // Add and start Pacman scene
                const pacmanScene = new PacmanScene();
                game.addScene(pacmanScene);
                await game.switchScene('pacman');
                
                console.log('Scene switched, input system:', game.input);
                
                // Handle restart
                game.on('input:keydown', (event) => {
                    console.log('Key pressed:', event.code);
                    if (event.code === 'Space' && game.paused) {
                        document.getElementById('gameOver').style.display = 'none';
                        
                        // Reset game
                        pacmanScene.score = 0;
                        pacmanScene.lives = 3;
                        document.getElementById('score').textContent = '0';
                        document.getElementById('lives').textContent = '3';
                        
                        // Reload scene
                        game.resume();
                        game.switchScene('pacman');
                    }
                });
                
                console.log('Pacman game started!');
                console.log('Use arrow keys or WASD to move');
                
            } catch (error) {
                console.error('Failed to start game:', error);
                document.getElementById('loadingText').textContent = 'Error: ' + error.message;
            }
        });
    </script>
</body>
</html>