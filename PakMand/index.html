<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pacman - GameFramework</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        
        #gameContainer {
            position: relative;
            border: 2px solid #00f;
            box-shadow: 0 0 20px #00f;
        }
        
        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            color: #fff;
            font-size: 18px;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f00;
            font-size: 48px;
            font-weight: bold;
            text-align: center;
            display: none;
            text-shadow: 3px 3px 0 #000;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="ui-overlay">
            <div>SCORE: <span id="score">0</span></div>
            <div>LIVES: <span id="lives">3</span></div>
        </div>
        <div class="game-over" id="gameOver">
            GAME OVER<br>
            <span style="font-size: 24px">PRESS SPACE TO RESTART</span>
        </div>
        <div class="loading" id="loadingText">Loading GameFramework...</div>
    </div>

    <!-- Load GameFramework -->
    <script src="../GameFramework/index.js" type="module"></script>
    
    <!-- Pacman Game Code -->
    <script type="module">
        // Wait for framework to load
        window.addEventListener('gameframework:ready', async (event) => {
            const GameFramework = event.detail.framework;
            
            // Game Constants
            const TILE_SIZE = 32;
            const MAZE_WIDTH = 19;
            const MAZE_HEIGHT = 21;
            const GHOST_COUNT = 4;
            
            // Maze layout (1 = wall, 0 = pellet, 2 = power pellet, 3 = empty)
            const MAZE = [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
                [1,2,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,2,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
                [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
                [1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1],
                [3,3,3,1,0,1,0,0,0,0,0,0,0,1,0,1,3,3,3],
                [1,1,1,1,0,1,0,1,1,3,1,1,0,1,0,1,1,1,1],
                [0,0,0,0,0,0,0,1,3,3,3,1,0,0,0,0,0,0,0],
                [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
                [3,3,3,1,0,1,0,0,0,0,0,0,0,1,0,1,3,3,3],
                [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
                [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
                [1,2,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,2,1],
                [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
                [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
                [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ];
            
            // Create Pacman Component
            class PacmanController extends GameFramework.Component {
                constructor() {
                    super();
                    this.speed = 150;
                    this.direction = { x: 0, y: 0 };
                    this.nextDirection = { x: 0, y: 0 };
                    this.gridX = 9;
                    this.gridY = 15;
                    this.animTimer = 0;
                    this.mouthOpen = true;
                }
                
                start() {
                    // Center on starting grid position
                    this.entity.position.x = this.gridX * TILE_SIZE + TILE_SIZE / 2;
                    this.entity.position.y = this.gridY * TILE_SIZE + TILE_SIZE / 2;
                    console.log('Pacman started at:', this.entity.position);
                    
                    // Start moving left by default
                    this.direction = { x: -1, y: 0 };
                    this.nextDirection = { x: -1, y: 0 };
                }
                
                update(deltaTime) {
                    if (!this.enabled) return;
                    
                    const input = this.engine.input;
                    const scene = this.scene;
                    
                    // Handle input - use isKeyPressed for continuous movement
                    if (input.isKeyPressed('ArrowLeft') || input.isKeyPressed('KeyA')) {
                        this.nextDirection = { x: -1, y: 0 };
                    } else if (input.isKeyPressed('ArrowRight') || input.isKeyPressed('KeyD')) {
                        this.nextDirection = { x: 1, y: 0 };
                    } else if (input.isKeyPressed('ArrowUp') || input.isKeyPressed('KeyW')) {
                        this.nextDirection = { x: 0, y: -1 };
                    } else if (input.isKeyPressed('ArrowDown') || input.isKeyPressed('KeyS')) {
                        this.nextDirection = { x: 0, y: 1 };
                    }
                    
                    // Get current grid position
                    const currentGridX = Math.floor(this.entity.position.x / TILE_SIZE);
                    const currentGridY = Math.floor(this.entity.position.y / TILE_SIZE);
                    
                    // Try to apply next direction
                    if (this.nextDirection.x !== 0 || this.nextDirection.y !== 0) {
                        const testX = currentGridX + this.nextDirection.x;
                        const testY = currentGridY + this.nextDirection.y;
                        
                        if (this.canMoveTo(testX, testY)) {
                            this.direction = { ...this.nextDirection };
                        }
                    }
                    
                    // Always try to move in current direction
                    if (this.direction.x !== 0 || this.direction.y !== 0) {
                        const moveSpeed = this.speed * deltaTime;
                        const newX = this.entity.position.x + this.direction.x * moveSpeed;
                        const newY = this.entity.position.y + this.direction.y * moveSpeed;
                        
                        // Simple collision check - just check the grid we're moving into
                        const checkGridX = Math.floor(newX / TILE_SIZE);
                        const checkGridY = Math.floor(newY / TILE_SIZE);
                        
                        if (this.canMoveTo(checkGridX, checkGridY)) {
                            this.entity.position.x = newX;
                            this.entity.position.y = newY;
                            
                            // Animate mouth
                            this.animTimer += deltaTime;
                            if (this.animTimer > 0.1) {
                                this.mouthOpen = !this.mouthOpen;
                                this.animTimer = 0;
                            }
                        }
                    }
                    
                    // Update current grid position for pellet collection
                    this.gridX = Math.round((this.entity.position.x - TILE_SIZE / 2) / TILE_SIZE);
                    this.gridY = Math.round((this.entity.position.y - TILE_SIZE / 2) / TILE_SIZE);
                    
                    // Collect pellets
                    if (scene.maze[this.gridY] && scene.maze[this.gridY][this.gridX] === 0) {
                        scene.maze[this.gridY][this.gridX] = 3; // Empty
                        scene.score += 10;
                        scene.pelletsRemaining--;
                        document.getElementById('score').textContent = scene.score;
                        
                        if (scene.pelletsRemaining === 0) {
                            scene.gameWon();
                        }
                    } else if (scene.maze[this.gridY] && scene.maze[this.gridY][this.gridX] === 2) {
                        scene.maze[this.gridY][this.gridX] = 3; // Empty
                        scene.score += 50;
                        scene.pelletsRemaining--;
                        scene.activatePowerMode();
                        document.getElementById('score').textContent = scene.score;
                    }
                }
                
                canMoveTo(x, y) {
                    // Check bounds
                    if (x < 0 || x >= MAZE_WIDTH || y < 0 || y >= MAZE_HEIGHT) {
                        return false;
                    }
                    // Check if it's a wall  
                    const scene = this.entity ? this.entity.scene : null;
                    if (!scene || !scene.maze || !scene.maze[y]) {
                        return true; // Allow movement if scene not ready
                    }
                    return scene.maze[y][x] !== 1;
                }
                
                render(context) {
                    // Draw Pacman as a yellow circle with mouth
                    context.fillStyle = '#ffff00';
                    
                    if (this.mouthOpen && (this.direction.x !== 0 || this.direction.y !== 0)) {
                        // Calculate mouth angle based on direction
                        let startAngle = 0;
                        if (this.direction.x > 0) startAngle = 0.25 * Math.PI;
                        else if (this.direction.x < 0) startAngle = 1.25 * Math.PI;
                        else if (this.direction.y > 0) startAngle = 0.75 * Math.PI;
                        else if (this.direction.y < 0) startAngle = 1.75 * Math.PI;
                        
                        context.beginPath();
                        context.moveTo(0, 0);
                        context.arc(0, 0, 12, startAngle, startAngle + 1.5 * Math.PI);
                        context.closePath();
                        context.fill();
                    } else {
                        context.beginPath();
                        context.arc(0, 0, 12, 0, 2 * Math.PI);
                        context.fill();
                    }
                }
            }
            
            // Ghost AI Component
            class GhostAI extends GameFramework.Component {
                constructor(color, startX, startY) {
                    super();
                    this.color = color;
                    this.speed = 100;
                    this.gridX = startX;
                    this.gridY = startY;
                    this.direction = { x: 0, y: -1 };
                    this.state = 'scatter'; // scatter, chase, frightened
                    this.frightenedTimer = 0;
                    this.animTimer = 0;
                    this.animFrame = 0;
                }
                
                start() {
                    this.entity.position.x = this.gridX * TILE_SIZE + TILE_SIZE / 2;
                    this.entity.position.y = this.gridY * TILE_SIZE + TILE_SIZE / 2;
                }
                
                update(deltaTime) {
                    const scene = this.scene;
                    const pacman = scene.pacman;
                    
                    // Update frightened state
                    if (this.state === 'frightened') {
                        this.frightenedTimer -= deltaTime;
                        if (this.frightenedTimer <= 0) {
                            this.state = 'chase';
                        }
                    }
                    
                    // Get current grid position
                    const currentGridX = Math.round((this.entity.position.x - TILE_SIZE / 2) / TILE_SIZE);
                    const currentGridY = Math.round((this.entity.position.y - TILE_SIZE / 2) / TILE_SIZE);
                    
                    // At intersection, choose new direction
                    if (Math.abs(this.entity.position.x - (currentGridX * TILE_SIZE + TILE_SIZE / 2)) < 2 &&
                        Math.abs(this.entity.position.y - (currentGridY * TILE_SIZE + TILE_SIZE / 2)) < 2) {
                        
                        const possibleDirs = [];
                        const dirs = [
                            { x: 0, y: -1 }, // up
                            { x: 1, y: 0 },  // right
                            { x: 0, y: 1 },  // down
                            { x: -1, y: 0 }  // left
                        ];
                        
                        // Don't reverse direction unless frightened
                        dirs.forEach(dir => {
                            if (this.state !== 'frightened' && 
                                dir.x === -this.direction.x && dir.y === -this.direction.y) {
                                return; // Skip reverse
                            }
                            
                            const nextX = currentGridX + dir.x;
                            const nextY = currentGridY + dir.y;
                            
                            if (this.canMoveTo(nextX, nextY)) {
                                possibleDirs.push(dir);
                            }
                        });
                        
                        if (possibleDirs.length > 0) {
                            if (this.state === 'frightened') {
                                // Random direction when frightened
                                this.direction = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                            } else if (this.state === 'chase' && pacman) {
                                // Chase Pacman
                                const pacmanGridX = Math.round((pacman.position.x - TILE_SIZE / 2) / TILE_SIZE);
                                const pacmanGridY = Math.round((pacman.position.y - TILE_SIZE / 2) / TILE_SIZE);
                                
                                let bestDir = possibleDirs[0];
                                let bestDist = Infinity;
                                
                                possibleDirs.forEach(dir => {
                                    const nextX = currentGridX + dir.x;
                                    const nextY = currentGridY + dir.y;
                                    const dist = Math.abs(nextX - pacmanGridX) + Math.abs(nextY - pacmanGridY);
                                    
                                    if (dist < bestDist) {
                                        bestDist = dist;
                                        bestDir = dir;
                                    }
                                });
                                
                                this.direction = bestDir;
                            } else {
                                // Scatter mode - random
                                this.direction = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                            }
                        }
                    }
                    
                    // Move ghost
                    const speed = this.state === 'frightened' ? this.speed * 0.5 : this.speed;
                    this.entity.position.x += this.direction.x * speed * deltaTime;
                    this.entity.position.y += this.direction.y * speed * deltaTime;
                    
                    // Check collision with Pacman
                    if (pacman) {
                        const dist = this.entity.position.distanceTo(pacman.position);
                        if (dist < 20) {
                            if (this.state === 'frightened') {
                                // Ghost eaten
                                scene.score += 200;
                                document.getElementById('score').textContent = scene.score;
                                // Reset ghost
                                this.gridX = 9;
                                this.gridY = 9;
                                this.entity.position.x = this.gridX * TILE_SIZE + TILE_SIZE / 2;
                                this.entity.position.y = this.gridY * TILE_SIZE + TILE_SIZE / 2;
                                this.state = 'scatter';
                            } else {
                                // Pacman caught
                                scene.loseLife();
                            }
                        }
                    }
                    
                    // Animate
                    this.animTimer += deltaTime;
                    if (this.animTimer > 0.2) {
                        this.animFrame = (this.animFrame + 1) % 2;
                        this.animTimer = 0;
                    }
                }
                
                canMoveTo(x, y) {
                    // Check bounds
                    if (x < 0 || x >= MAZE_WIDTH || y < 0 || y >= MAZE_HEIGHT) {
                        return false;
                    }
                    // Check if it's a wall
                    const scene = this.entity ? this.entity.scene : null;
                    if (!scene || !scene.maze || !scene.maze[y]) {
                        return true; // Allow movement if scene not ready
                    }
                    return scene.maze[y][x] !== 1;
                }
                
                setFrightened() {
                    this.state = 'frightened';
                    this.frightenedTimer = 8;
                }
                
                render(context) {
                    // Ghost body
                    context.fillStyle = this.state === 'frightened' ? '#0000ff' : this.color;
                    context.beginPath();
                    context.arc(0, -4, 12, Math.PI, 0);
                    context.lineTo(12, 8);
                    
                    // Wavy bottom
                    for (let i = 0; i < 4; i++) {
                        const x = 12 - (i * 8);
                        const y = 8 + (this.animFrame === 0 ? 2 : -2) * (i % 2 === 0 ? 1 : -1);
                        context.lineTo(x, y);
                    }
                    
                    context.closePath();
                    context.fill();
                    
                    // Eyes
                    context.fillStyle = '#ffffff';
                    context.beginPath();
                    context.arc(-5, -4, 3, 0, Math.PI * 2);
                    context.arc(5, -4, 3, 0, Math.PI * 2);
                    context.fill();
                    
                    // Pupils
                    context.fillStyle = this.state === 'frightened' ? '#ffffff' : '#000000';
                    context.beginPath();
                    context.arc(-5 + this.direction.x * 2, -4 + this.direction.y * 2, 1.5, 0, Math.PI * 2);
                    context.arc(5 + this.direction.x * 2, -4 + this.direction.y * 2, 1.5, 0, Math.PI * 2);
                    context.fill();
                }
            }
            
            // Game Scene
            class PacmanScene extends GameFramework.Scene {
                constructor() {
                    super('pacman', {
                        backgroundColor: '#000000'
                    });
                    
                    this.maze = [];
                    this.score = 0;
                    this.lives = 3;
                    this.pelletsRemaining = 0;
                    this.powerMode = false;
                    this.powerTimer = 0;
                    this.pacman = null;
                    this.ghosts = [];
                }
                
                async onLoad() {
                    document.getElementById('loadingText').textContent = 'Loading assets...';
                    
                    // Try multiple paths for karateguy sprite
                    const spritePaths = [
                        'karateguy.json',
                        'assets/sprites/karateguy.json',
                        'GameAssets/Sprites/Aseprite/karateguy.json',
                        '/GameAssets/Sprites/Aseprite/karateguy.json'
                    ];
                    
                    let spriteLoaded = false;
                    for (const path of spritePaths) {
                        try {
                            await this.engine.assets.load('karateguy', path);
                            console.log('Karateguy sprite loaded from:', path);
                            spriteLoaded = true;
                            break;
                        } catch (e) {
                            console.log('Failed to load from:', path);
                        }
                    }
                    
                    if (!spriteLoaded) {
                        console.log('Could not load karateguy sprite from any path, using default rendering');
                    }
                    
                    document.getElementById('loadingText').style.display = 'none';
                    
                    // Initialize maze
                    this.initializeMaze();
                    
                    // Create Pacman
                    this.createPacman();
                    
                    // Create ghosts
                    this.createGhosts();
                    
                    // Create maze walls
                    this.createMazeWalls();
                }
                
                initializeMaze() {
                    // Deep copy maze and count pellets
                    this.maze = MAZE.map(row => [...row]);
                    this.pelletsRemaining = 0;
                    
                    for (let y = 0; y < MAZE_HEIGHT; y++) {
                        for (let x = 0; x < MAZE_WIDTH; x++) {
                            if (this.maze[y][x] === 0 || this.maze[y][x] === 2) {
                                this.pelletsRemaining++;
                            }
                        }
                    }
                }
                
                createPacman() {
                    const pacman = new GameFramework.Entity({
                        name: 'Pacman',
                        x: 0,
                        y: 0,
                        layer: 2
                    });
                    
                    // Add PacmanController first
                    const controller = new PacmanController();
                    pacman.addComponent(controller);
                    
                    // Check if we have the karateguy sprite
                    if (this.engine.assets.has('karateguy')) {
                        const renderer = new GameFramework.Components.AsepriteRenderer('karateguy');
                        pacman.addComponent(renderer);
                        
                        // Check if it's animated
                        const spriteData = this.engine.renderer.getSpriteData('karateguy');
                        if (spriteData && spriteData.animations && spriteData.animations.size > 0) {
                            const animSprite = new GameFramework.Components.AnimatedSprite('karateguy');
                            pacman.addComponent(animSprite);
                            // Try to play idle or walk animation
                            if (animSprite.hasAnimation('idle')) {
                                animSprite.play('idle');
                            } else if (animSprite.hasAnimation('walk')) {
                                animSprite.play('walk');
                            }
                        }
                    }
                    
                    this.addEntity(pacman);
                    this.pacman = pacman;
                    
                    console.log('Pacman created at position:', pacman.position);
                }
                
                createGhosts() {
                    const ghostColors = ['#ff0000', '#00ffff', '#ffb8ff', '#ffb852'];
                    const ghostPositions = [
                        { x: 9, y: 9 },
                        { x: 8, y: 9 },
                        { x: 10, y: 9 },
                        { x: 9, y: 10 }
                    ];
                    
                    for (let i = 0; i < GHOST_COUNT; i++) {
                        const ghost = new GameFramework.Entity({
                            name: `Ghost${i}`,
                            x: 0,
                            y: 0,
                            layer: 2
                        });
                        
                        ghost.addComponent(new GhostAI(
                            ghostColors[i],
                            ghostPositions[i].x,
                            ghostPositions[i].y
                        ));
                        
                        this.addEntity(ghost);
                        this.ghosts.push(ghost);
                    }
                }
                
                createMazeWalls() {
                    // Create visual maze representation
                    const mazeEntity = new GameFramework.Entity({
                        name: 'Maze',
                        x: 0,
                        y: 0,
                        layer: 0
                    });
                    
                    const mazeRenderer = new GameFramework.Component();
                    mazeRenderer.render = function(context) {
                        const scene = this.scene;
                        
                        // Draw maze
                        for (let y = 0; y < MAZE_HEIGHT; y++) {
                            for (let x = 0; x < MAZE_WIDTH; x++) {
                                const tile = scene.maze[y][x];
                                const px = x * TILE_SIZE;
                                const py = y * TILE_SIZE;
                                
                                if (tile === 1) {
                                    // Wall
                                    context.fillStyle = '#0000ff';
                                    context.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                                    
                                    // Inner border
                                    context.strokeStyle = '#4040ff';
                                    context.lineWidth = 2;
                                    context.strokeRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                                } else if (tile === 0) {
                                    // Pellet
                                    context.fillStyle = '#ffff00';
                                    context.beginPath();
                                    context.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, 3, 0, Math.PI * 2);
                                    context.fill();
                                } else if (tile === 2) {
                                    // Power pellet
                                    context.fillStyle = '#ffff00';
                                    context.beginPath();
                                    context.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, 8, 0, Math.PI * 2);
                                    context.fill();
                                }
                            }
                        }
                    };
                    
                    mazeEntity.addComponent(mazeRenderer);
                    this.addEntity(mazeEntity);
                }
                
                onActivate() {
                    // Reset score and lives display
                    document.getElementById('score').textContent = this.score;
                    document.getElementById('lives').textContent = this.lives;
                    
                    // Create a game logic entity to handle scene updates
                    const gameLogic = new GameFramework.Entity({
                        name: 'GameLogic',
                        x: 0,
                        y: 0
                    });
                    
                    const logicComponent = new GameFramework.Component();
                    logicComponent.update = (deltaTime) => {
                        // Update power mode
                        if (this.powerMode) {
                            this.powerTimer -= deltaTime;
                            if (this.powerTimer <= 0) {
                                this.powerMode = false;
                                // Reset ghost states
                                this.ghosts.forEach(ghost => {
                                    const ai = ghost.getComponent(GhostAI);
                                    if (ai) ai.state = 'chase';
                                });
                            }
                        }
                    };
                    
                    gameLogic.addComponent(logicComponent);
                    this.addEntity(gameLogic);
                }
                
                activatePowerMode() {
                    this.powerMode = true;
                    this.powerTimer = 8;
                    
                    // Make ghosts frightened
                    this.ghosts.forEach(ghost => {
                        const ai = ghost.getComponent(GhostAI);
                        if (ai) ai.setFrightened();
                    });
                }
                
                loseLife() {
                    this.lives--;
                    document.getElementById('lives').textContent = this.lives;
                    
                    if (this.lives <= 0) {
                        this.gameOver();
                    } else {
                        // Reset positions
                        const pacmanController = this.pacman.getComponent(PacmanController);
                        pacmanController.gridX = 9;
                        pacmanController.gridY = 15;
                        pacmanController.direction = { x: 0, y: 0 };
                        this.pacman.position.x = pacmanController.gridX * TILE_SIZE + TILE_SIZE / 2;
                        this.pacman.position.y = pacmanController.gridY * TILE_SIZE + TILE_SIZE / 2;
                        
                        // Reset ghosts
                        const ghostPositions = [
                            { x: 9, y: 9 },
                            { x: 8, y: 9 },
                            { x: 10, y: 9 },
                            { x: 9, y: 10 }
                        ];
                        
                        this.ghosts.forEach((ghost, i) => {
                            const ai = ghost.getComponent(GhostAI);
                            ai.gridX = ghostPositions[i].x;
                            ai.gridY = ghostPositions[i].y;
                            ghost.position.x = ai.gridX * TILE_SIZE + TILE_SIZE / 2;
                            ghost.position.y = ai.gridY * TILE_SIZE + TILE_SIZE / 2;
                            ai.state = 'scatter';
                        });
                    }
                }
                
                gameOver() {
                    this.engine.pause();
                    document.getElementById('gameOver').style.display = 'block';
                }
                
                gameWon() {
                    // Reset level with bonus
                    this.score += 1000;
                    document.getElementById('score').textContent = this.score;
                    this.initializeMaze();
                    
                    // Increase difficulty
                    this.ghosts.forEach(ghost => {
                        const ai = ghost.getComponent(GhostAI);
                        ai.speed = Math.min(ai.speed * 1.1, 180);
                    });
                }
            }
            
            // Initialize game
            try {
                const game = await GameFramework.quickStart('gameCanvas', {
                    width: MAZE_WIDTH * TILE_SIZE,
                    height: MAZE_HEIGHT * TILE_SIZE,
                    backgroundColor: '#000000',
                    smoothing: false,
                    debug: true  // Enable debug mode
                });
                
                console.log('Game engine created');
                
                // Add and start Pacman scene
                const pacmanScene = new PacmanScene();
                game.addScene(pacmanScene);
                await game.switchScene('pacman');
                
                console.log('Scene switched, input system:', game.input);
                
                // Handle restart
                game.on('input:keydown', (event) => {
                    console.log('Key pressed:', event.code);
                    if (event.code === 'Space' && game.paused) {
                        document.getElementById('gameOver').style.display = 'none';
                        
                        // Reset game
                        pacmanScene.score = 0;
                        pacmanScene.lives = 3;
                        document.getElementById('score').textContent = '0';
                        document.getElementById('lives').textContent = '3';
                        
                        // Reload scene
                        game.resume();
                        game.switchScene('pacman');
                    }
                });
                
                console.log('Pacman game started!');
                console.log('Use arrow keys or WASD to move');
                
            } catch (error) {
                console.error('Failed to start game:', error);
                document.getElementById('loadingText').textContent = 'Error: ' + error.message;
            }
        });
    </script>
</body>
</html>