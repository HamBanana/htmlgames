<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Karate Fighter</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Courier New', monospace;
            color: #ffffff;
        }
        
        h1 {
            color: #ff6b35;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }
        
        .game-info {
            text-align: center;
            margin-bottom: 20px;
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ff6b35;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 12px;
        }
        
        #gameCanvas {
            border: 3px solid #ff6b35;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.3);
            background: #000;
        }
        
        .loading {
            text-align: center;
            margin-top: 20px;
            color: #ff6b35;
        }
        
        .error {
            color: #ff4444;
            background: rgba(255, 68, 68, 0.1);
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        
        .status {
            margin-top: 10px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <h1>ðŸ¥‹ KARATE FIGHTER</h1>
    
    <div class="game-info">
        <div class="controls">
            <div><strong>Movement:</strong> WASD / Arrow Keys</div>
            <div><strong>Attack:</strong> E</div>
            <div><strong>Special:</strong> Space</div>
            <div><strong>Block:</strong> Q</div>
        </div>
    </div>
    
    <canvas id="gameCanvas" width="1000" height="600"></canvas>
    
    <div id="status" class="status">Initializing game framework...</div>
    
    <!-- Load GameFramework -->
    <script src="../GameFramework/index.js"></script>
    
    <script>
        // Game state
        let game;
        let player;
        let enemies = [];
        let score = 0;
        let wave = 1;
        let enemySpawnTimer = 0;
        let gameStarted = false;
        
        // Status display
        const statusEl = document.getElementById('status');
        
        function updateStatus(message) {
            statusEl.textContent = message;
            console.log('ðŸŽ®', message);
        }
        
        // Health Component
        class HealthComponent extends Component {
            constructor(config = {}) {
                super(config);
                this.maxHealth = config.maxHealth || 100;
                this.health = config.health || this.maxHealth;
                this.invulnerable = false;
                this.invulnerabilityTime = 0;
                this.onDeath = config.onDeath;
                this.onDamage = config.onDamage;
            }
            
            update(deltaTime) {
                if (this.invulnerabilityTime > 0) {
                    this.invulnerabilityTime -= deltaTime;
                    if (this.invulnerabilityTime <= 0) {
                        this.invulnerable = false;
                    }
                }
            }
            
            takeDamage(amount) {
                if (this.invulnerable || this.health <= 0) return false;
                
                this.health -= amount;
                this.health = Math.max(0, this.health);
                
                // Brief invulnerability after taking damage
                this.invulnerable = true;
                this.invulnerabilityTime = 0.5;
                
                if (this.onDamage) {
                    this.onDamage(amount);
                }
                
                if (this.health <= 0) {
                    this.die();
                }
                
                return true;
            }
            
            heal(amount) {
                this.health += amount;
                this.health = Math.min(this.maxHealth, this.health);
            }
            
            die() {
                if (this.onDeath) {
                    this.onDeath();
                }
                
                game.events.emit('entity:death', this.entity);
            }
        }
        
        // Fighter Component for combat mechanics
        class FighterComponent extends Component {
            constructor(config = {}) {
                super(config);
                this.attackPower = config.attackPower || 20;
                this.attackRange = config.attackRange || 60;
                this.attackCooldown = config.attackCooldown || 0.5;
                this.specialCooldown = config.specialCooldown || 3;
                this.blocking = false;
                this.attacking = false;
                this.canAttack = true;
                this.canSpecial = true;
                this.attackTimer = 0;
                this.specialTimer = 0;
                this.comboCount = 0;
                this.lastAttackTime = 0;
            }
            
            update(deltaTime) {
                // Update timers
                if (this.attackTimer > 0) {
                    this.attackTimer -= deltaTime;
                    if (this.attackTimer <= 0) {
                        this.canAttack = true;
                        this.attacking = false;
                    }
                }
                
                if (this.specialTimer > 0) {
                    this.specialTimer -= deltaTime;
                    if (this.specialTimer <= 0) {
                        this.canSpecial = true;
                    }
                }
                
                // Reset combo if too much time passes
                if (Date.now() - this.lastAttackTime > 2000) {
                    this.comboCount = 0;
                }
            }
            
            attack() {
                if (!this.canAttack) return false;
                
                this.attacking = true;
                this.canAttack = false;
                this.attackTimer = this.attackCooldown;
                this.lastAttackTime = Date.now();
                this.comboCount++;
                
                // Play attack animation
                const animation = this.entity.getComponent(AnimationComponent);
                if (animation) {
                    animation.play('attack', true);
                }
                
                // Check for targets in range
                this.checkAttackTargets();
                
                // Create attack effect
                game.createParticleEffect('hit', 
                    this.entity.x + (this.entity.width * 0.8), 
                    this.entity.y + this.entity.height * 0.5
                );
                
                game.playSound('punch');
                
                return true;
            }
            
            specialAttack() {
                if (!this.canSpecial) return false;
                
                this.canSpecial = false;
                this.specialTimer = this.specialCooldown;
                this.comboCount += 2;
                
                // Play special animation
                const animation = this.entity.getComponent(AnimationComponent);
                if (animation) {
                    animation.play('special', true);
                }
                
                // More powerful attack with larger range
                this.checkAttackTargets(this.attackRange * 1.5, this.attackPower * 2);
                
                // Screen shake for impact
                game.shake(15, 0.3);
                
                // Special effect
                game.createParticleEffect('explosion', 
                    this.entity.x + this.entity.width * 0.5, 
                    this.entity.y + this.entity.height * 0.5
                );
                
                game.playSound('special');
                
                return true;
            }
            
            checkAttackTargets(range = this.attackRange, power = this.attackPower) {
                // Find enemies in attack range
                const attackX = this.entity.x + this.entity.width;
                const attackY = this.entity.y + this.entity.height * 0.5;
                
                const allEntities = game.getAllEntities();
                
                allEntities.forEach(target => {
                    if (target === this.entity) return;
                    if (target.type === this.entity.type) return; // Don't attack same type
                    
                    const distance = Math.sqrt(
                        Math.pow(target.x - attackX, 2) + 
                        Math.pow(target.y + target.height * 0.5 - attackY, 2)
                    );
                    
                    if (distance <= range) {
                        this.hitTarget(target, power);
                    }
                });
            }
            
            hitTarget(target, damage) {
                const health = target.getComponent(HealthComponent);
                const fighter = target.getComponent(FighterComponent);
                
                // Check if target is blocking
                if (fighter && fighter.blocking) {
                    damage *= 0.3; // Reduced damage when blocking
                    game.createParticleEffect('sparkle', target.x, target.y);
                    game.playSound('block');
                } else {
                    // Full damage hit
                    game.createParticleEffect('blood', target.x, target.y);
                }
                
                if (health) {
                    const damaged = health.takeDamage(damage);
                    if (damaged) {
                        // Knockback
                        const physics = target.getComponent(PhysicsComponent);
                        if (physics) {
                            physics.velocity.x += (this.entity.x < target.x ? 200 : -200);
                        }
                        
                        // Add score for player hits
                        if (this.entity.type === 'player') {
                            score += Math.floor(damage);
                            updateScore();
                        }
                    }
                }
            }
            
            block(blocking) {
                this.blocking = blocking;
                
                // Play block animation
                if (blocking) {
                    const animation = this.entity.getComponent(AnimationComponent);
                    if (animation) {
                        animation.play('block', true);
                    }
                }
            }
        }
        
        // AI Component for enemy behavior
        class AIComponent extends Component {
            constructor(config = {}) {
                super(config);
                this.state = 'patrol';
                this.targetPlayer = null;
                this.patrolDistance = config.patrolDistance || 200;
                this.detectionRange = config.detectionRange || 150;
                this.attackRange = config.attackRange || 70;
                this.moveSpeed = config.moveSpeed || 100;
                this.patrolCenter = null;
                this.patrolDirection = 1;
                this.stateTimer = 0;
                this.attackCooldown = 0;
            }
            
            initialize() {
                this.patrolCenter = this.entity.x;
            }
            
            update(deltaTime) {
                this.stateTimer += deltaTime;
                this.attackCooldown -= deltaTime;
                
                // Find player
                if (!this.targetPlayer || this.targetPlayer.health <= 0) {
                    const players = game.getEntitiesByType('player');
                    this.targetPlayer = players.length > 0 ? players[0] : null;
                }
                
                if (!this.targetPlayer) return;
                
                const distanceToPlayer = this.entity.position.distanceTo(this.targetPlayer.position);
                
                // State machine
                switch (this.state) {
                    case 'patrol':
                        this.patrol(deltaTime);
                        
                        if (distanceToPlayer <= this.detectionRange) {
                            this.state = 'chase';
                            this.stateTimer = 0;
                        }
                        break;
                        
                    case 'chase':
                        this.chasePlayer(deltaTime);
                        
                        if (distanceToPlayer <= this.attackRange) {
                            this.state = 'attack';
                            this.stateTimer = 0;
                        } else if (distanceToPlayer > this.detectionRange * 1.5) {
                            this.state = 'patrol';
                            this.stateTimer = 0;
                        }
                        break;
                        
                    case 'attack':
                        this.attackPlayer(deltaTime);
                        
                        if (distanceToPlayer > this.attackRange * 1.2) {
                            this.state = 'chase';
                            this.stateTimer = 0;
                        }
                        break;
                }
            }
            
            patrol(deltaTime) {
                const physics = this.entity.getComponent(PhysicsComponent);
                const sprite = this.entity.getComponent(SpriteComponent);
                
                if (physics) {
                    const targetX = this.patrolCenter + (this.patrolDirection * this.patrolDistance);
                    
                    if (Math.abs(this.entity.x - targetX) < 10) {
                        this.patrolDirection *= -1;
                    }
                    
                    physics.velocity.x = this.patrolDirection * this.moveSpeed * 0.5;
                    
                    // Update sprite direction
                    if (sprite) {
                        sprite.flipX = this.patrolDirection < 0;
                    }
                }
            }
            
            chasePlayer(deltaTime) {
                const physics = this.entity.getComponent(PhysicsComponent);
                const sprite = this.entity.getComponent(SpriteComponent);
                
                if (physics && this.targetPlayer) {
                    const direction = this.targetPlayer.x > this.entity.x ? 1 : -1;
                    physics.velocity.x = direction * this.moveSpeed;
                    
                    // Update sprite direction
                    if (sprite) {
                        sprite.flipX = direction < 0;
                    }
                    
                    // Play run animation
                    const animation = this.entity.getComponent(AnimationComponent);
                    if (animation) {
                        animation.play('run');
                    }
                }
            }
            
            attackPlayer(deltaTime) {
                const physics = this.entity.getComponent(PhysicsComponent);
                const fighter = this.entity.getComponent(FighterComponent);
                
                // Stop moving
                if (physics) {
                    physics.velocity.x = 0;
                }
                
                // Attack if cooldown is ready
                if (this.attackCooldown <= 0 && fighter) {
                    if (Math.random() < 0.3) { // 30% chance for special attack
                        fighter.specialAttack();
                        this.attackCooldown = 2;
                    } else {
                        fighter.attack();
                        this.attackCooldown = 1;
                    }
                }
                
                // Sometimes block
                if (fighter && Math.random() < 0.1) {
                    fighter.block(true);
                } else if (fighter) {
                    fighter.block(false);
                }
            }
        }
        
        // Create Player Entity
        function createPlayer(x, y) {
            const player = new BaseEntity({
                type: 'player',
                x: x,
                y: y,
                width: 64,
                height: 64
            });
            
            // Add components
            player.addComponent(new SpriteComponent('karateguy'));
            player.addComponent(new AnimationComponent({ autoLoadAnimations: true }));
            player.addComponent(new PhysicsComponent({
                useGravity: true,
                gravityScale: 1,
                maxVelocityX: 300,
                maxVelocityY: 600
            }));
            player.addComponent(new CollisionComponent({
                width: 48,
                height: 60,
                offsetX: 8,
                offsetY: 4
            }));
            player.addComponent(new HealthComponent({
                maxHealth: 200,
                onDeath: () => {
                    updateStatus('Game Over! Final Score: ' + score);
                    // Restart after delay
                    setTimeout(() => {
                        restartGame();
                    }, 3000);
                },
                onDamage: (amount) => {
                    game.shake(8, 0.2);
                    updatePlayerHealth();
                }
            }));
            player.addComponent(new FighterComponent({
                attackPower: 25,
                attackRange: 70,
                attackCooldown: 0.4,
                specialCooldown: 2.5
            }));
            
            return player;
        }
        
        // Create Enemy Entity
        function createEnemy(x, y) {
            const enemy = new BaseEntity({
                type: 'enemy',
                x: x,
                y: y,
                width: 64,
                height: 64,
                zIndex: 1
            });
            
            // Add components
            enemy.addComponent(new SpriteComponent('ninjamand'));
            enemy.addComponent(new AnimationComponent({ autoLoadAnimations: true }));
            enemy.addComponent(new PhysicsComponent({
                useGravity: true,
                gravityScale: 1,
                maxVelocityX: 200,
                maxVelocityY: 600
            }));
            enemy.addComponent(new CollisionComponent({
                width: 48,
                height: 60,
                offsetX: 8,
                offsetY: 4
            }));
            enemy.addComponent(new HealthComponent({
                maxHealth: 60 + (wave * 10),
                onDeath: () => {
                    // Remove from enemies array
                    const index = enemies.indexOf(enemy);
                    if (index > -1) {
                        enemies.splice(index, 1);
                    }
                    
                    // Add score
                    score += 100 + (wave * 25);
                    updateScore();
                    
                    // Death effect
                    game.createParticleEffect('explosion', enemy.x, enemy.y);
                    game.playSound('enemy_death');
                    
                    // Check if wave is complete
                    if (enemies.length === 0) {
                        startNextWave();
                    }
                }
            }));
            enemy.addComponent(new FighterComponent({
                attackPower: 15 + (wave * 3),
                attackRange: 65,
                attackCooldown: 0.8,
                specialCooldown: 4
            }));
            enemy.addComponent(new AIComponent({
                moveSpeed: 80 + (wave * 10),
                detectionRange: 180,
                attackRange: 70
            }));
            
            enemies.push(enemy);
            return enemy;
        }
        
        // Player Input Handler
        function handlePlayerInput() {
            const input = game.getSystem('input');
            if (!input || !player) return;
            
            const physics = player.getComponent(PhysicsComponent);
            const fighter = player.getComponent(FighterComponent);
            const animation = player.getComponent(AnimationComponent);
            const sprite = player.getComponent(SpriteComponent);
            
            if (!physics || !fighter) return;
            
            // Movement
            let moving = false;
            if (input.isActionPressed('left')) {
                physics.velocity.x = -200;
                if (sprite) sprite.flipX = true;
                moving = true;
            } else if (input.isActionPressed('right')) {
                physics.velocity.x = 200;
                if (sprite) sprite.flipX = false;
                moving = true;
            } else {
                physics.velocity.x *= 0.8; // Friction
            }
            
            // Jump
            if (input.isActionJustPressed('up') && physics.grounded) {
                physics.velocity.y = -350;
                game.playSound('jump');
            }
            
            // Combat
            if (input.isActionJustPressed('action')) {
                fighter.attack();
            }
            
            if (input.isActionJustPressed('jump')) {
                fighter.specialAttack();
            }
            
            // Block
            if (input.isActionPressed('pause')) { // Q key for block
                fighter.block(true);
            } else {
                fighter.block(false);
            }
            
            // Animations
            if (animation && !fighter.attacking) {
                if (!physics.grounded) {
                    animation.play('jump');
                } else if (fighter.blocking) {
                    animation.play('block');
                } else if (moving) {
                    animation.play('run');
                } else {
                    animation.play('idle');
                }
            }
        }
        
        // UI Updates
        function updateScore() {
            const scoreDisplay = document.querySelector('.score');
            if (scoreDisplay) {
                scoreDisplay.textContent = `Score: ${score}`;
            }
        }
        
        function updatePlayerHealth() {
            const health = player?.getComponent(HealthComponent);
            if (health) {
                const healthDisplay = document.querySelector('.health');
                if (healthDisplay) {
                    const percentage = (health.health / health.maxHealth) * 100;
                    healthDisplay.textContent = `Health: ${Math.ceil(health.health)}/${health.maxHealth}`;
                    healthDisplay.style.color = percentage > 50 ? '#00ff00' : percentage > 25 ? '#ffff00' : '#ff0000';
                }
            }
        }
        
        // Wave Management
        function startNextWave() {
            wave++;
            updateStatus(`Wave ${wave} incoming...`);
            
            setTimeout(() => {
                const enemyCount = Math.min(3 + wave, 8);
                for (let i = 0; i < enemyCount; i++) {
                    const x = 900 + (i * 100);
                    const y = 400;
                    const enemy = createEnemy(x, y);
                    game.addEntity(enemy);
                }
                updateStatus(`Wave ${wave} - ${enemyCount} enemies!`);
            }, 2000);
        }
        
        // Game Management
        function restartGame() {
            // Reset game state
            score = 0;
            wave = 1;
            enemies = [];
            
            // Clear entities
            game.getAllEntities().forEach(entity => {
                if (entity !== player) {
                    game.removeEntity(entity);
                }
            });
            
            // Reset player
            if (player) {
                const health = player.getComponent(HealthComponent);
                if (health) {
                    health.health = health.maxHealth;
                }
                player.x = 100;
                player.y = 400;
            }
            
            // Start first wave
            startNextWave();
            updateScore();
            updatePlayerHealth();
        }
        
        // Initialize the game
        async function initGame() {
            try {
                updateStatus('Waiting for GameFramework...');
                
                // Wait for framework to be ready
                await GameFramework.ready();
                
                updateStatus('Creating game instance...');
                
                // Create game
                game = new GameFramework.Game({
                    width: 1000,
                    height: 600,
                    backgroundColor: '#2c3e50',
                    gravity: 800,
                    debug: false,
                    controls: {
                        left: ['ArrowLeft', 'KeyA'],
                        right: ['ArrowRight', 'KeyD'],
                        up: ['ArrowUp', 'KeyW'],
                        down: ['ArrowDown', 'KeyS'],
                        jump: ['Space'],
                        action: ['KeyE'],
                        pause: ['KeyQ']
                    }
                });
                
                await game.ready;
                
                updateStatus('Loading sprites...');
                
                // Load sprites
                await game.loadSprite('karateguy', 'karateguy.json');
                await game.loadSprite('ninjamand', 'ninjamand.json');
                
                updateStatus('Setting up game world...');
                
                // Create ground
                const ground = new BaseEntity({
                    type: 'ground',
                    x: 0,
                    y: 500,
                    width: 1000,
                    height: 100,
                    visible: true
                });
                
                ground.addComponent(new ColliderComponent({
                    static: true,
                    width: 1000,
                    height: 100
                }));
                
                // Custom ground render
                ground.render = function(context) {
                    context.fillStyle = '#8b4513';
                    context.fillRect(0, 0, this.width, this.height);
                    context.fillStyle = '#228b22';
                    context.fillRect(0, 0, this.width, 10);
                };
                
                game.addEntity(ground);
                
                // Create player
                player = createPlayer(100, 400);
                game.addEntity(player);
                
                // Set up camera to follow player
                const camera = game.getSystem('camera');
                if (camera) {
                    camera.follow(player);
                    camera.bounds = { x: 0, y: 0, width: 1000, height: 600 };
                }
                
                // Add UI elements
                addGameUI();
                
                // Start the game
                game.start();
                
                // Set up input handling
                game.events.on('game:update', handlePlayerInput);
                
                updateStatus('Game ready! Fight!');
                gameStarted = true;
                
                // Start first wave
                setTimeout(() => {
                    startNextWave();
                }, 1000);
                
            } catch (error) {
                console.error('Failed to initialize game:', error);
                updateStatus(`Error: ${error.message}`);
            }
        }
        
        function addGameUI() {
            // Create UI elements
            const uiHTML = `
                <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; font-family: monospace; color: white;">
                    <div class="score">Score: 0</div>
                    <div class="health">Health: 200/200</div>
                    <div class="wave">Wave: 1</div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', uiHTML);
            updateScore();
            updatePlayerHealth();
        }
        
        // Start the game when the page loads
        window.addEventListener('gameframework:ready', initGame);
        window.addEventListener('load', () => {
            if (window.GameFramework && window.GameFramework.loaded) {
                initGame();
            }
        });
        
    </script>
</body>
</html>