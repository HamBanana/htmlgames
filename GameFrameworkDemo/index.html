<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameFramework Example</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        canvas {
            border: 2px solid #333;
            background-color: #000;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .controls {
            margin-top: 20px;
            text-align: center;
        }
        
        .controls h3 {
            margin-bottom: 10px;
            color: #4CAF50;
        }
        
        .controls p {
            margin: 5px 0;
            color: #ccc;
        }
        
        .info {
            margin-top: 20px;
            padding: 15px;
            background-color: #2a2a2a;
            border-radius: 8px;
            max-width: 800px;
        }
        
        .info h3 {
            color: #4CAF50;
            margin-top: 0;
        }
        
        .asset-status {
            margin-top: 15px;
            padding: 10px;
            background-color: #333;
            border-radius: 5px;
        }
        
        .loaded { color: #4CAF50; }
        .loading { color: #FFC107; }
        .error { color: #f44336; }
    </style>
</head>
<body>
    <h1>🎮 GameFramework Demo</h1>
    <canvas id="gameCanvas"></canvas>
    
    <div class="controls">
        <h3>Controls</h3>
        <p><strong>Arrow Keys / WASD:</strong> Move Player</p>
        <p><strong>Space:</strong> Jump</p>
        <p><strong>X:</strong> Shoot</p>
        <p><strong>R:</strong> Restart Level</p>
    </div>
    
    <div class="info">
        <h3>GameFramework Features Demonstrated</h3>
        <p>✅ <strong>Entity-Component-System Architecture:</strong> Player, enemies, and platforms as entities with modular components</p>
        <p>✅ <strong>Physics System:</strong> Gravity, velocity, and collision detection</p>
        <p>✅ <strong>Animation System:</strong> Sprite animation with Aseprite support</p>
        <p>✅ <strong>Input Handling:</strong> Keyboard input with action mapping</p>
        <p>✅ <strong>Camera System:</strong> Following camera with bounds and shake effects</p>
        <p>✅ <strong>Particle System:</strong> Explosion and trail effects</p>
        <p>✅ <strong>Audio System:</strong> Sound effects and background music</p>
        <p>✅ <strong>Scene Management:</strong> Game scenes with loading/unloading</p>
        <p>✅ <strong>Asset Loading:</strong> Centralized asset management with framework paths</p>
        
        <div class="asset-status">
            <h4>Asset Loading Status:</h4>
            <div id="assetStatus">Framework initializing...</div>
            <div id="loadingSummary" style="margin-top: 10px; padding: 8px; background: #444; border-radius: 4px;">
                <strong>Loading Summary:</strong> <span id="summaryText">Waiting to start...</span>
            </div>
            <div style="margin-top: 8px; font-size: 12px; color: #888;">
                <p><strong>Path Resolution:</strong> Framework uses absolute paths from server root (starting with '/').</p>
                <p><strong>Example:</strong> <code>'/GameFramework/Assets/Sprites/Aseprite/karateguy.json'</code> resolves to <code>localhost:8081/GameFramework/Assets/Sprites/Aseprite/karateguy.json</code></p>
                <p><strong>Note:</strong> This demo attempts to load real assets from /GameFramework/Assets/. 
                Since these files don't exist in this environment, you'll see actual loading failures.</p>
                <p>In a real implementation, place your Aseprite JSON files, audio files, etc. in the Assets folder structure at your server root.</p>
            </div>
        </div>
    </div>

    <!-- Include the complete GameFramework -->
    <script>
        // This would normally be in separate files:
        // framework-config.js, framework-utils.js, framework-systems.js, 
        // framework-components.js, game-framework.js
        
        // For this demo, we'll simulate the framework being loaded
        // In a real implementation, you'd include the separate JS files
        
        // framework-config.js content would be here
        const FRAMEWORK_CONFIG = {
            // Asset path configuration (absolute paths from server root)
            // Leading '/' ensures paths are relative to server root, not current page
            paths: {
                base: '/GameFramework/Assets/',
                sprites: '/GameFramework/Assets/Sprites/Aseprite/',
                audio: {
                    base: '/GameFramework/Assets/Audio/',
                    music: '/GameFramework/Assets/Audio/Music/',
                    sfx: '/GameFramework/Assets/Audio/SFX/'
                }
            },
            assetTypes: {
                sprites: {
                    defaultFormat: 'aseprite',
                    supportedFormats: ['json', 'png', 'jpg'],
                    defaultExtension: '.json'
                }
            },
            loading: {
                showProgress: true,
                enableCaching: true
            }
        };

        // Vector2 class
        class Vector2 {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }
            
            set(x, y) {
                this.x = x;
                this.y = y;
                return this;
            }
            
            copy() {
                return new Vector2(this.x, this.y);
            }
            
            add(v) {
                return new Vector2(this.x + v.x, this.y + v.y);
            }
            
            subtract(v) {
                return new Vector2(this.x - v.x, this.y - v.y);
            }
            
            multiply(scalar) {
                return new Vector2(this.x * scalar, this.y * scalar);
            }
            
            magnitude() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }
            
            normalize() {
                const mag = this.magnitude();
                if (mag === 0) return new Vector2(0, 0);
                return new Vector2(this.x / mag, this.y / mag);
            }
            
            distanceTo(v) {
                const dx = this.x - v.x;
                const dy = this.y - v.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }

        // EventEmitter class
        class EventEmitter {
            constructor() {
                this.events = new Map();
            }
            
            on(event, callback) {
                if (!this.events.has(event)) {
                    this.events.set(event, []);
                }
                this.events.get(event).push(callback);
                return this;
            }
            
            emit(event, ...args) {
                if (this.events.has(event)) {
                    this.events.get(event).forEach(callback => {
                        callback(...args);
                    });
                }
                return this;
            }
        }

        // PerformanceMonitor class
        class PerformanceMonitor {
            constructor() {
                this.frameCount = 0;
                this.fps = 0;
                this.lastTime = 0;
                this.frameTime = 0;
                this.measurements = new Map();
            }
            
            startFrame() {
                this.frameStart = performance.now();
            }
            
            endFrame() {
                this.frameTime = performance.now() - this.frameStart;
                this.frameCount++;
                
                const now = performance.now();
                if (now - this.lastTime >= 1000) {
                    this.fps = Math.round((this.frameCount * 1000) / (now - this.lastTime));
                    this.frameCount = 0;
                    this.lastTime = now;
                }
            }
            
            measure(name, fn) {
                const start = performance.now();
                const result = fn();
                const time = performance.now() - start;
                this.measurements.set(name, time);
                return result;
            }
            
            getStats() {
                return {
                    fps: this.fps,
                    frameTime: this.frameTime,
                    breakdown: Object.fromEntries(this.measurements)
                };
            }
        }

        // System base class
        class System {
            constructor(config = {}) {
                this.config = config;
                this.game = null;
            }
            
            initialize() {}
            start() {}
            stop() {}
            update(deltaTime) {}
        }

        // Input System
        class InputSystem extends System {
            constructor(config = {}) {
                super(config);
                this.keys = new Map();
                this.keysJustPressed = new Set();
                this.keysJustReleased = new Set();
                this.mouse = { x: 0, y: 0, buttons: new Map() };
                this.actionMappings = config.keyboard || {};
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                document.addEventListener('keydown', (e) => this.onKeyDown(e));
                document.addEventListener('keyup', (e) => this.onKeyUp(e));
                document.addEventListener('mousemove', (e) => this.onMouseMove(e));
                document.addEventListener('mousedown', (e) => this.onMouseDown(e));
                document.addEventListener('mouseup', (e) => this.onMouseUp(e));
            }
            
            onKeyDown(event) {
                if (!this.keys.get(event.code)) {
                    this.keysJustPressed.add(event.code);
                }
                this.keys.set(event.code, true);
            }
            
            onKeyUp(event) {
                this.keys.set(event.code, false);
                this.keysJustReleased.add(event.code);
            }
            
            onMouseMove(event) {
                const rect = this.game.canvas.getBoundingClientRect();
                this.mouse.x = event.clientX - rect.left;
                this.mouse.y = event.clientY - rect.top;
            }
            
            onMouseDown(event) {
                this.mouse.buttons.set(event.button, true);
            }
            
            onMouseUp(event) {
                this.mouse.buttons.set(event.button, false);
            }
            
            update(deltaTime) {
                this.keysJustPressed.clear();
                this.keysJustReleased.clear();
            }
            
            isKeyPressed(key) {
                return this.keys.get(key) || false;
            }
            
            isKeyJustPressed(key) {
                return this.keysJustPressed.has(key);
            }
            
            isActionPressed(action) {
                const keys = this.actionMappings[action];
                if (!keys) return false;
                return keys.some(key => this.isKeyPressed(key));
            }
            
            isActionJustPressed(action) {
                const keys = this.actionMappings[action];
                if (!keys) return false;
                return keys.some(key => this.isKeyJustPressed(key));
            }
            
            getMovementVector() {
                let x = 0;
                let y = 0;
                
                if (this.isActionPressed('left')) x -= 1;
                if (this.isActionPressed('right')) x += 1;
                if (this.isActionPressed('up')) y -= 1;
                if (this.isActionPressed('down')) y += 1;
                
                if (x !== 0 && y !== 0) {
                    const length = Math.sqrt(x * x + y * y);
                    x /= length;
                    y /= length;
                }
                
                return { x, y };
            }
        }

        // Physics System
        class PhysicsSystem extends System {
            constructor(config = {}) {
                super(config);
                this.gravity = config.gravity || 0.5;
                this.friction = config.friction || 0.1;
            }
            
            update(deltaTime) {
                const entities = this.game.getEntitiesWithComponent(PhysicsComponent);
                
                entities.forEach(entity => {
                    const physics = entity.getComponent(PhysicsComponent);
                    
                    if (physics.useGravity) {
                        physics.acceleration.y += this.gravity * physics.gravityScale;
                    }
                    
                    physics.forces.forEach(force => {
                        physics.acceleration.x += force.x / physics.mass;
                        physics.acceleration.y += force.y / physics.mass;
                    });
                    physics.forces = [];
                    
                    physics.velocity.x += physics.acceleration.x * deltaTime;
                    physics.velocity.y += physics.acceleration.y * deltaTime;
                    
                    physics.velocity.x *= (1 - physics.drag);
                    physics.velocity.y *= (1 - physics.drag);
                    
                    physics.velocity.x = Math.max(-physics.maxVelocity.x, 
                        Math.min(physics.maxVelocity.x, physics.velocity.x));
                    physics.velocity.y = Math.max(-physics.maxVelocity.y, 
                        Math.min(physics.maxVelocity.y, physics.velocity.y));
                    
                    entity.x += physics.velocity.x * deltaTime;
                    entity.y += physics.velocity.y * deltaTime;
                    
                    physics.acceleration.set(0, 0);
                });
            }
        }

        // Render System
        class RenderSystem extends System {
            constructor(canvas, context, config = {}) {
                super(config);
                this.canvas = canvas;
                this.context = context;
                this.sprites = new Map();
                this.backgroundColor = config.game?.backgroundColor || '#000000';
            }
            
            clear() {
                this.context.fillStyle = this.backgroundColor;
                this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            drawRect(x, y, width, height, color) {
                this.context.fillStyle = color;
                this.context.fillRect(x, y, width, height);
            }
            
            drawCircle(x, y, radius, color) {
                this.context.fillStyle = color;
                this.context.beginPath();
                this.context.arc(x, y, radius, 0, Math.PI * 2);
                this.context.fill();
            }
            
            drawText(text, x, y, options = {}) {
                this.context.fillStyle = options.color || '#ffffff';
                this.context.font = options.font || '16px Arial';
                this.context.textAlign = options.align || 'left';
                this.context.fillText(text, x, y);
            }
        }

        // Camera System
        class CameraSystem extends System {
            constructor(config = {}) {
                super(config);
                this.position = new Vector2(0, 0);
                this.target = null;
                this.followSpeed = 0.1;
                this.bounds = null;
                this.shake = { intensity: 0, duration: 0, timer: 0 };
            }
            
            follow(entity) {
                this.target = entity;
            }
            
            setBounds(x, y, width, height) {
                this.bounds = { x, y, width, height };
            }
            
            shake(intensity, duration) {
                this.shake.intensity = intensity;
                this.shake.duration = duration;
                this.shake.timer = duration;
            }
            
            update(deltaTime) {
                if (this.target) {
                    const targetX = this.target.x - this.game.canvas.width / 2;
                    const targetY = this.target.y - this.game.canvas.height / 2;
                    
                    this.position.x += (targetX - this.position.x) * this.followSpeed;
                    this.position.y += (targetY - this.position.y) * this.followSpeed;
                }
                
                if (this.bounds) {
                    this.position.x = Math.max(this.bounds.x, 
                        Math.min(this.bounds.width - this.game.canvas.width, this.position.x));
                    this.position.y = Math.max(this.bounds.y, 
                        Math.min(this.bounds.height - this.game.canvas.height, this.position.y));
                }
                
                if (this.shake.timer > 0) {
                    this.shake.timer -= deltaTime * 1000;
                }
            }
            
            applyTransform(context) {
                let offsetX = -this.position.x;
                let offsetY = -this.position.y;
                
                if (this.shake.timer > 0) {
                    const progress = this.shake.timer / this.shake.duration;
                    const shakeX = (Math.random() - 0.5) * this.shake.intensity * progress;
                    const shakeY = (Math.random() - 0.5) * this.shake.intensity * progress;
                    offsetX += shakeX;
                    offsetY += shakeY;
                }
                
                context.translate(offsetX, offsetY);
            }
        }

        // Particle System
        class ParticleSystem extends System {
            constructor(config = {}) {
                super(config);
                this.particles = [];
                this.effects = new Map();
            }
            
            registerEffect(name, config) {
                this.effects.set(name, config);
            }
            
            createEffect(name, x, y) {
                const effect = this.effects.get(name);
                if (!effect) return;
                
                for (let i = 0; i < effect.count; i++) {
                    this.emit({
                        position: { x, y },
                        ...effect
                    });
                }
            }
            
            emit(config) {
                const angle = Math.random() * (config.spread || Math.PI * 2);
                const speed = config.speed || 5;
                
                this.particles.push({
                    x: config.position.x,
                    y: config.position.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: config.lifetime || 60,
                    maxLife: config.lifetime || 60,
                    color: config.color || '#ffffff',
                    size: config.size || 4,
                    gravity: config.gravity || 0
                });
            }
            
            update(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    particle.x += particle.vx * deltaTime;
                    particle.y += particle.vy * deltaTime;
                    particle.vy += particle.gravity * deltaTime;
                    particle.life--;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            render(context) {
                this.particles.forEach(particle => {
                    const alpha = particle.life / particle.maxLife;
                    context.save();
                    context.globalAlpha = alpha;
                    context.fillStyle = particle.color;
                    context.beginPath();
                    context.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    context.fill();
                    context.restore();
                });
            }
        }

        // Component base class
        class Component {
            constructor(config = {}) {
                this.entity = null;
                this.active = config.active !== false;
                this.visible = config.visible !== false;
            }
            
            get game() {
                return this.entity ? this.entity.game : null;
            }
            
            initialize() {}
            update(deltaTime) {}
            render(context) {}
            destroy() {}
        }

        // Physics Component
        class PhysicsComponent extends Component {
            constructor(config = {}) {
                super(config);
                this.velocity = new Vector2(config.vx || 0, config.vy || 0);
                this.acceleration = new Vector2(0, 0);
                this.forces = [];
                this.mass = config.mass || 1;
                this.drag = config.drag || 0;
                this.useGravity = config.useGravity !== false;
                this.gravityScale = config.gravityScale || 1;
                this.grounded = false;
                this.maxVelocity = new Vector2(
                    config.maxVelocityX || 20,
                    config.maxVelocityY || 20
                );
            }
            
            addForce(force) {
                this.forces.push(force);
            }
            
            setVelocity(x, y) {
                this.velocity.set(x, y);
            }
        }

        // Health Component
        class HealthComponent extends Component {
            constructor(config = {}) {
                super(config);
                this.maxHealth = config.maxHealth || 100;
                this.health = config.health || this.maxHealth;
                this.invulnerable = false;
                this.invulnerabilityTime = config.invulnerabilityTime || 1000;
                this.invulnerabilityTimer = 0;
                
                this.onDamage = config.onDamage;
                this.onHeal = config.onHeal;
                this.onDeath = config.onDeath;
            }
            
            takeDamage(amount) {
                if (this.invulnerable || this.health <= 0) return;
                
                this.health = Math.max(0, this.health - amount);
                this.invulnerable = true;
                this.invulnerabilityTimer = this.invulnerabilityTime;
                
                if (this.onDamage) {
                    this.onDamage(amount);
                }
                
                if (this.health <= 0 && this.onDeath) {
                    this.onDeath();
                }
                
                this.game.events.emit('entity:damage', {
                    entity: this.entity,
                    amount,
                    health: this.health
                });
            }
            
            heal(amount) {
                const oldHealth = this.health;
                this.health = Math.min(this.maxHealth, this.health + amount);
                const healed = this.health - oldHealth;
                
                if (healed > 0 && this.onHeal) {
                    this.onHeal(healed);
                }
            }
            
            update(deltaTime) {
                if (this.invulnerable && this.invulnerabilityTimer > 0) {
                    this.invulnerabilityTimer -= deltaTime * 1000;
                    if (this.invulnerabilityTimer <= 0) {
                        this.invulnerable = false;
                    }
                }
            }
            
            isDead() {
                return this.health <= 0;
            }
            
            getHealthPercent() {
                return this.health / this.maxHealth;
            }
        }

        // Input Component
        class InputComponent extends Component {
            constructor(config = {}) {
                super(config);
                this.inputEnabled = true;
            }
            
            isActionPressed(action) {
                const input = this.game.getSystem('input');
                return input && input.isActionPressed(action);
            }
            
            isActionJustPressed(action) {
                const input = this.game.getSystem('input');
                return input && input.isActionJustPressed(action);
            }
            
            getMovementVector() {
                const input = this.game.getSystem('input');
                return input ? input.getMovementVector() : { x: 0, y: 0 };
            }
        }

        // Base Entity
        class BaseEntity {
            constructor(config = {}) {
                this.id = config.id || null;
                this.type = config.type || 'entity';
                this.name = config.name || '';
                
                this.position = new Vector2(config.x || 0, config.y || 0);
                this.size = new Vector2(config.width || 32, config.height || 32);
                this.rotation = config.rotation || 0;
                this.scale = new Vector2(config.scaleX || 1, config.scaleY || 1);
                
                this.active = config.active !== false;
                this.visible = config.visible !== false;
                this.zIndex = config.zIndex || 0;
                
                this.components = new Map();
                this.game = null;
            }
            
            initialize() {
                this.components.forEach(component => {
                    if (component.initialize) {
                        component.initialize();
                    }
                });
            }
            
            addComponent(component) {
                const componentType = component.constructor;
                this.components.set(componentType, component);
                component.entity = this;
                
                if (this.game && component.initialize) {
                    component.initialize();
                }
                
                return this;
            }
            
            removeComponent(ComponentClass) {
                const component = this.components.get(ComponentClass);
                if (component) {
                    if (component.destroy) {
                        component.destroy();
                    }
                    this.components.delete(ComponentClass);
                }
                return this;
            }
            
            getComponent(ComponentClass) {
                return this.components.get(ComponentClass);
            }
            
            hasComponent(ComponentClass) {
                return this.components.has(ComponentClass);
            }
            
            update(deltaTime) {
                this.components.forEach(component => {
                    if (component.active && component.update) {
                        component.update(deltaTime);
                    }
                });
            }
            
            render(context) {
                context.save();
                
                context.translate(this.position.x, this.position.y);
                context.rotate(this.rotation);
                context.scale(this.scale.x, this.scale.y);
                
                this.components.forEach(component => {
                    if (component.visible && component.render) {
                        component.render(context);
                    }
                });
                
                context.restore();
            }
            
            destroy() {
                this.components.forEach(component => {
                    if (component.destroy) {
                        component.destroy();
                    }
                });
                this.components.clear();
                
                if (this.game) {
                    this.game.removeEntity(this);
                }
            }
            
            get x() { return this.position.x; }
            set x(value) { this.position.x = value; }
            
            get y() { return this.position.y; }
            set y(value) { this.position.y = value; }
            
            get width() { return this.size.x; }
            set width(value) { this.size.x = value; }
            
            get height() { return this.size.y; }
            set height(value) { this.size.y = value; }
        }

        // Scene base class
        class Scene {
            constructor(name) {
                this.name = name;
                this.game = null;
                this.entities = [];
            }
            
            async onLoad() {}
            async onUnload() {}
            
            update(deltaTime) {}
            render(context) {}
            
            addEntity(entity) {
                if (!this.entities.includes(entity)) {
                    this.entities.push(entity);
                }
            }
            
            removeEntity(entity) {
                const index = this.entities.indexOf(entity);
                if (index > -1) {
                    this.entities.splice(index, 1);
                }
            }
        }

        // Asset Loader
        class AssetLoader {
            constructor(framework) {
                this.framework = framework;
                this.config = FRAMEWORK_CONFIG;
                this.loadedAssets = new Map();
                this.loadingPromises = new Map();
                this.loadAttempts = new Map();
            }
            
            async initialize() {
                console.log('🔧 Framework Asset Loader initialized');
                console.log('📂 Asset paths configured:');
                console.log(`  Sprites: ${this.config.paths.sprites}`);
                console.log(`  Audio SFX: ${this.config.paths.audio.sfx}`);
                console.log(`  Audio Music: ${this.config.paths.audio.music}`);
                
                this.updateAssetStatus('Framework initialized - Ready to load assets');
            }
            
            updateAssetStatus(message) {
                const statusEl = document.getElementById('assetStatus');
                if (statusEl) {
                    statusEl.innerHTML += '<br>' + message;
                }
            }
            
            async loadSprite(assetId, filename) {
                const fullPath = this.config.paths.sprites + filename;
                
                if (this.loadedAssets.has(assetId)) {
                    return this.loadedAssets.get(assetId);
                }
                
                if (this.loadingPromises.has(assetId)) {
                    return this.loadingPromises.get(assetId);
                }
                
                this.updateAssetStatus(`<span class="loading">🔄 Loading sprite: ${assetId}</span>`);
                this.updateAssetStatus(`<span class="loading">   📍 Full path: ${fullPath}</span>`);
                
                const loadPromise = this.doLoadSprite(assetId, fullPath);
                this.loadingPromises.set(assetId, loadPromise);
                
                try {
                    const startTime = performance.now();
                    const spriteData = await loadPromise;
                    const loadTime = performance.now() - startTime;
                    
                    this.loadedAssets.set(assetId, spriteData);
                    this.updateAssetStatus(`<span class="loaded">✅ Successfully loaded sprite: ${assetId} (${loadTime.toFixed(1)}ms)</span>`);
                    
                    this.framework.events.emit('asset:loaded', {
                        type: 'sprite',
                        id: assetId,
                        filename: filename,
                        fullPath: fullPath,
                        loadTime: loadTime,
                        success: true
                    });
                    
                    return spriteData;
                } catch (error) {
                    this.loadingPromises.delete(assetId);
                    const attempts = (this.loadAttempts.get(assetId) || 0) + 1;
                    this.loadAttempts.set(assetId, attempts);
                    
                    this.updateAssetStatus(`<span class="error">❌ Failed to load sprite: ${assetId}</span>`);
                    this.updateAssetStatus(`<span class="error">   💥 Error: ${error.message}</span>`);
                    
                    console.error(`Failed to load sprite ${assetId} from ${fullPath}:`, error);
                    
                    // Return a fallback placeholder for demo purposes
                    const fallback = {
                        id: assetId,
                        filename: filename,
                        fullPath: fullPath,
                        loaded: false,
                        error: error.message,
                        placeholder: true
                    };
                    
                    return fallback;
                }
            }
            
            async doLoadSprite(assetId, fullPath) {
                // Try to load as Aseprite JSON first
                try {
                    const response = await fetch(fullPath);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText} for ${fullPath}`);
                    }
                    
                    const jsonData = await response.json();
                    
                    // Validate Aseprite format
                    if (!jsonData.frames || !jsonData.meta) {
                        throw new Error('Invalid Aseprite format - missing frames or meta data');
                    }
                    
                    // Parse the sprite data
                    const spriteData = this.parseAsepriteData(jsonData);
                    
                    // Try to load the embedded image
                    if (jsonData.meta.image && jsonData.meta.image.startsWith('data:image/')) {
                        try {
                            const image = await this.loadImageFromBase64(jsonData.meta.image);
                            spriteData.image = image;
                            spriteData.imageLoaded = true;
                        } catch (imgError) {
                            console.warn(`Failed to load embedded image for ${assetId}:`, imgError);
                            spriteData.imageLoaded = false;
                        }
                    } else {
                        spriteData.imageLoaded = false;
                        console.warn(`No embedded image data found in sprite ${assetId}`);
                    }
                    
                    spriteData.loaded = true;
                    return spriteData;
                    
                } catch (jsonError) {
                    // If JSON loading fails, try as regular image
                    console.log(`Aseprite JSON load failed for ${assetId}, trying as regular image:`, jsonError.message);
                    
                    try {
                        const image = await this.loadImageFromUrl(fullPath.replace('.json', '.png'));
                        return {
                            id: assetId,
                            image: image,
                            loaded: true,
                            imageLoaded: true,
                            isRegularImage: true,
                            frames: new Map([['0', { x: 0, y: 0, w: image.width, h: image.height }]]),
                            animations: new Map()
                        };
                    } catch (imgError) {
                        throw new Error(`Failed to load as both Aseprite JSON and regular image: ${jsonError.message} | ${imgError.message}`);
                    }
                }
            }
            
            parseAsepriteData(jsonData) {
                const frames = new Map();
                const animations = new Map();
                
                // Parse frames
                if (jsonData.frames) {
                    if (Array.isArray(jsonData.frames)) {
                        jsonData.frames.forEach((frame, index) => {
                            frames.set(index.toString(), {
                                x: frame.frame.x,
                                y: frame.frame.y,
                                w: frame.frame.w,
                                h: frame.frame.h,
                                duration: frame.duration || 100
                            });
                        });
                    } else {
                        Object.entries(jsonData.frames).forEach(([name, frame]) => {
                            frames.set(name, {
                                x: frame.frame.x,
                                y: frame.frame.y,
                                w: frame.frame.w,
                                h: frame.frame.h,
                                duration: frame.duration || 100
                            });
                        });
                    }
                }
                
                // Parse animations (frame tags)
                if (jsonData.meta?.frameTags) {
                    jsonData.meta.frameTags.forEach(tag => {
                        animations.set(tag.name, {
                            from: tag.from,
                            to: tag.to,
                            direction: tag.direction || 'forward',
                            repeat: tag.repeat !== undefined ? tag.repeat : -1
                        });
                    });
                }
                
                return {
                    frames,
                    animations,
                    meta: jsonData.meta
                };
            }
            
            async loadImageFromBase64(base64Data) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error('Failed to decode base64 image data'));
                    img.src = base64Data;
                });
            }
            
            async loadImageFromUrl(url) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error(`Failed to load image from ${url}`));
                    img.src = url;
                });
            }
            
            async loadAudio(assetId, filename, type = 'sfx') {
                const basePath = type === 'music' ? this.config.paths.audio.music : this.config.paths.audio.sfx;
                const fullPath = basePath + filename;
                
                if (this.loadedAssets.has(assetId)) {
                    return this.loadedAssets.get(assetId);
                }
                
                this.updateAssetStatus(`<span class="loading">🔄 Loading audio: ${assetId}</span>`);
                this.updateAssetStatus(`<span class="loading">   📍 Full path: ${fullPath}</span>`);
                
                try {
                    const startTime = performance.now();
                    const audio = await this.doLoadAudio(assetId, fullPath);
                    const loadTime = performance.now() - startTime;
                    
                    const audioData = {
                        id: assetId,
                        filename: filename,
                        type: type,
                        fullPath: fullPath,
                        audio: audio,
                        loaded: true
                    };
                    
                    this.loadedAssets.set(assetId, audioData);
                    this.updateAssetStatus(`<span class="loaded">✅ Successfully loaded audio: ${assetId} (${loadTime.toFixed(1)}ms)</span>`);
                    
                    this.framework.events.emit('asset:loaded', {
                        type: 'audio',
                        id: assetId,
                        filename: filename,
                        fullPath: fullPath,
                        audioType: type,
                        loadTime: loadTime,
                        success: true
                    });
                    
                    return audioData;
                } catch (error) {
                    const attempts = (this.loadAttempts.get(assetId) || 0) + 1;
                    this.loadAttempts.set(assetId, attempts);
                    
                    this.updateAssetStatus(`<span class="error">❌ Failed to load audio: ${assetId}</span>`);
                    this.updateAssetStatus(`<span class="error">   💥 Error: ${error.message}</span>`);
                    
                    console.error(`Failed to load audio ${assetId} from ${fullPath}:`, error);
                    
                    // Return a fallback for demo purposes
                    return {
                        id: assetId,
                        filename: filename,
                        type: type,
                        fullPath: fullPath,
                        loaded: false,
                        error: error.message
                    };
                }
            }
            
            async doLoadAudio(assetId, fullPath) {
                return new Promise((resolve, reject) => {
                    const audio = new Audio();
                    
                    const timeout = setTimeout(() => {
                        reject(new Error(`Audio load timeout for ${fullPath}`));
                    }, 5000);
                    
                    audio.addEventListener('canplaythrough', () => {
                        clearTimeout(timeout);
                        resolve(audio);
                    }, { once: true });
                    
                    audio.addEventListener('error', () => {
                        clearTimeout(timeout);
                        reject(new Error(`Failed to load audio from ${fullPath}: ${audio.error?.message || 'Unknown error'}`));
                    }, { once: true });
                    
                    audio.preload = 'auto';
                    audio.src = fullPath;
                });
            }
            
            getAsset(assetId) {
                return this.loadedAssets.get(assetId);
            }
            
            hasAsset(assetId) {
                const asset = this.loadedAssets.get(assetId);
                return asset && asset.loaded;
            }
            
            getLoadingStats() {
                const total = this.loadAttempts.size;
                const loaded = Array.from(this.loadedAssets.values()).filter(asset => asset.loaded).length;
                const failed = total - loaded;
                
                return {
                    total,
                    loaded,
                    failed,
                    loadedAssets: Array.from(this.loadedAssets.keys()).filter(id => this.hasAsset(id))
                };
            }
        }

        // Main GameFramework class
        class GameFramework {
            constructor(config = {}) {
                this.config = this.mergeWithDefaults(config);
                this.assetLoader = new AssetLoader(this);
                this.canvas = null;
                this.context = null;
                this.running = false;
                this.paused = false;
                
                this.systems = new Map();
                this.entities = new Map();
                this.scenes = new Map();
                this.currentScene = null;
                
                this.events = new EventEmitter();
                this.performanceMonitor = new PerformanceMonitor();
                
                this.initializeSystems();
            }
            
            mergeWithDefaults(config) {
                const defaults = {
                    game: {
                        width: 800,
                        height: 600,
                        fps: 60,
                        backgroundColor: '#2a2a2a',
                        debug: true
                    },
                    physics: {
                        gravity: 800,
                        friction: 0.1
                    },
                    rendering: {
                        pixelated: true,
                        antialias: false
                    }
                };
                
                return this.deepMerge(defaults, config);
            }
            
            deepMerge(target, source) {
                const output = Object.assign({}, target);
                if (this.isObject(target) && this.isObject(source)) {
                    Object.keys(source).forEach(key => {
                        if (this.isObject(source[key])) {
                            if (!(key in target))
                                Object.assign(output, { [key]: source[key] });
                            else
                                output[key] = this.deepMerge(target[key], source[key]);
                        } else {
                            Object.assign(output, { [key]: source[key] });
                        }
                    });
                }
                return output;
            }
            
            isObject(item) {
                return item && typeof item === 'object' && !Array.isArray(item);
            }
            
            initializeSystems() {
                this.registerSystem('input', new InputSystem(this.config.input));
                this.registerSystem('physics', new PhysicsSystem(this.config.physics));
                this.registerSystem('camera', new CameraSystem(this.config.game));
                this.registerSystem('particles', new ParticleSystem(this.config.particles));
            }
            
            async initialize(canvasId = 'gameCanvas') {
                this.canvas = document.getElementById(canvasId);
                if (!this.canvas) {
                    this.canvas = document.createElement('canvas');
                    this.canvas.id = canvasId;
                    document.body.appendChild(this.canvas);
                }
                
                this.canvas.width = this.config.game.width;
                this.canvas.height = this.config.game.height;
                
                this.context = this.canvas.getContext('2d');
                this.context.imageSmoothingEnabled = !this.config.rendering.pixelated;
                
                this.registerSystem('renderer', new RenderSystem(this.canvas, this.context, this.config));
                
                await this.assetLoader.initialize();
                
                this.events.emit('game:initialized');
                
                return this;
            }
            
            registerSystem(name, system) {
                system.game = this;
                this.systems.set(name, system);
                
                if (system.initialize) {
                    system.initialize();
                }
                
                this.events.emit('system:registered', { name, system });
            }
            
            getSystem(name) {
                return this.systems.get(name);
            }
            
            addEntity(entity) {
                if (!entity.id) {
                    entity.id = this.generateEntityId();
                }
                
                this.entities.set(entity.id, entity);
                entity.game = this;
                
                if (entity.initialize) {
                    entity.initialize();
                }
                
                if (this.currentScene) {
                    this.currentScene.addEntity(entity);
                }
                
                this.events.emit('entity:added', entity);
                
                return entity;
            }
            
            removeEntity(entity) {
                const id = typeof entity === 'string' ? entity : entity.id;
                const removedEntity = this.entities.get(id);
                
                if (removedEntity) {
                    if (removedEntity.destroy) {
                        removedEntity.destroy();
                    }
                    
                    this.entities.delete(id);
                    
                    if (this.currentScene) {
                        this.currentScene.removeEntity(removedEntity);
                    }
                    
                    this.events.emit('entity:removed', removedEntity);
                }
                
                return removedEntity;
            }
            
            getAllEntities() {
                return Array.from(this.entities.values());
            }
            
            getEntitiesByType(type) {
                return this.getAllEntities().filter(e => e.type === type);
            }
            
            getEntitiesWithComponent(ComponentClass) {
                return this.getAllEntities().filter(e => e.hasComponent(ComponentClass));
            }
            
            generateEntityId() {
                return `entity_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }
            
            registerScene(name, scene) {
                scene.game = this;
                scene.name = name;
                this.scenes.set(name, scene);
            }
            
            async loadScene(sceneName) {
                const scene = this.scenes.get(sceneName);
                if (!scene) {
                    throw new Error(`Scene '${sceneName}' not found`);
                }
                
                if (this.currentScene) {
                    await this.unloadCurrentScene();
                }
                
                this.currentScene = scene;
                
                if (scene.onLoad) {
                    await scene.onLoad();
                }
                
                this.events.emit('scene:loaded', scene);
                
                return scene;
            }
            
            async unloadCurrentScene() {
                if (!this.currentScene) return;
                
                if (this.currentScene.onUnload) {
                    await this.currentScene.onUnload();
                }
                
                const sceneEntities = this.currentScene.entities || [];
                sceneEntities.forEach(entity => this.removeEntity(entity));
                
                this.events.emit('scene:unloaded', this.currentScene);
                
                this.currentScene = null;
            }
            
            async loadSprite(assetId, filename) {
                return this.assetLoader.loadSprite(assetId, filename);
            }
            
            async loadAudio(assetId, filename, type = 'sfx') {
                return this.assetLoader.loadAudio(assetId, filename, type);
            }
            
            getAsset(assetId) {
                return this.assetLoader.getAsset(assetId);
            }
            
            hasAsset(assetId) {
                return this.assetLoader.hasAsset(assetId);
            }
            
            start() {
                if (this.running) return;
                
                this.running = true;
                this.lastTime = performance.now();
                
                this.systems.forEach(system => {
                    if (system.start) system.start();
                });
                
                this.events.emit('game:start');
                
                this.gameLoop();
            }
            
            stop() {
                this.running = false;
                
                this.systems.forEach(system => {
                    if (system.stop) system.stop();
                });
                
                this.events.emit('game:stop');
            }
            
            pause() {
                this.paused = true;
                this.events.emit('game:pause');
            }
            
            resume() {
                this.paused = false;
                this.events.emit('game:resume');
            }
            
            gameLoop(currentTime = performance.now()) {
                if (!this.running) return;
                
                requestAnimationFrame((time) => this.gameLoop(time));
                
                const deltaTime = Math.min((currentTime - this.lastTime) / 1000, 0.1);
                this.lastTime = currentTime;
                
                if (this.paused) return;
                
                this.performanceMonitor.startFrame();
                
                this.performanceMonitor.measure('update', () => {
                    this.update(deltaTime);
                });
                
                this.performanceMonitor.measure('render', () => {
                    this.render();
                });
                
                this.performanceMonitor.endFrame();
                
                if (this.config.game.debug) {
                    this.renderDebugInfo();
                }
            }
            
            update(deltaTime) {
                this.systems.forEach((system, name) => {
                    if (system.update) {
                        this.performanceMonitor.measure(`system:${name}`, () => {
                            system.update(deltaTime);
                        });
                    }
                });
                
                if (this.currentScene && this.currentScene.update) {
                    this.currentScene.update(deltaTime);
                }
                
                this.entities.forEach(entity => {
                    if (entity.active && entity.update) {
                        entity.update(deltaTime);
                    }
                });
                
                this.events.emit('game:update', deltaTime);
            }
            
            render() {
                const renderer = this.getSystem('renderer');
                if (!renderer) return;
                
                renderer.clear();
                
                const camera = this.getSystem('camera');
                if (camera) {
                    this.context.save();
                    camera.applyTransform(this.context);
                }
                
                if (this.currentScene && this.currentScene.render) {
                    this.currentScene.render(this.context);
                }
                
                const sortedEntities = this.getAllEntities()
                    .filter(e => e.active && e.visible)
                    .sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0));
                
                sortedEntities.forEach(entity => {
                    if (entity.render) {
                        entity.render(this.context);
                    }
                });
                
                const particles = this.getSystem('particles');
                if (particles && particles.render) {
                    particles.render(this.context);
                }
                
                if (camera) {
                    this.context.restore();
                }
                
                this.events.emit('game:render');
            }
            
            renderDebugInfo() {
                const stats = this.performanceMonitor.getStats();
                
                this.context.save();
                this.context.fillStyle = '#00ff00';
                this.context.font = '12px monospace';
                this.context.fillText(`FPS: ${stats.fps}`, 10, 20);
                this.context.fillText(`Entities: ${this.entities.size}`, 10, 35);
                this.context.restore();
            }
        }

        // Game entities
        class Player extends BaseEntity {
            constructor(x, y) {
                super({
                    x: x,
                    y: y,
                    width: 32,
                    height: 32,
                    type: 'player'
                });
                
                this.addComponent(new PhysicsComponent({
                    mass: 1,
                    useGravity: true,
                    maxVelocityX: 300,
                    maxVelocityY: 600,
                    drag: 0.8
                }));
                
                this.addComponent(new InputComponent());
                
                this.addComponent(new HealthComponent({
                    maxHealth: 100,
                    onDamage: (amount) => {
                        console.log(`Player took ${amount} damage!`);
                        const camera = this.game.getSystem('camera');
                        camera.shake(5, 200);
                    },
                    onDeath: () => {
                        console.log('Player died!');
                        this.respawn();
                    }
                }));
                
                this.jumpForce = -400;
                this.moveSpeed = 200;
                this.canJump = true;
            }
            
            update(deltaTime) {
                super.update(deltaTime);
                
                const input = this.getComponent(InputComponent);
                const physics = this.getComponent(PhysicsComponent);
                
                if (!input || !physics) return;
                
                // Handle restart
                if (input.isActionJustPressed('restart')) {
                    this.respawn();
                    return;
                }
                
                // Movement
                const movement = input.getMovementVector();
                physics.velocity.x = movement.x * this.moveSpeed;
                
                // Jumping
                if (input.isActionJustPressed('jump') && this.canJump) {
                    physics.velocity.y = this.jumpForce;
                    this.canJump = false;
                    
                    // Create jump particles
                    const particles = this.game.getSystem('particles');
                    particles.createEffect('jump', this.x + this.width/2, this.y + this.height);
                }
                
                // Shooting
                if (input.isActionJustPressed('shoot')) {
                    this.shoot();
                }
                
                // Ground check (simple)
                if (this.y > 500) {
                    this.canJump = true;
                    physics.grounded = true;
                } else {
                    physics.grounded = false;
                }
                
                // Death check
                if (this.y > 700) {
                    const health = this.getComponent(HealthComponent);
                    health.takeDamage(100);
                }
            }
            
            shoot() {
                const bullet = new Bullet(this.x + this.width, this.y + this.height/2);
                this.game.addEntity(bullet);
                
                const particles = this.game.getSystem('particles');
                particles.createEffect('muzzle', this.x + this.width, this.y + this.height/2);
            }
            
            respawn() {
                this.x = 100;
                this.y = 300;
                const physics = this.getComponent(PhysicsComponent);
                physics.velocity.set(0, 0);
                const health = this.getComponent(HealthComponent);
                health.health = health.maxHealth;
            }
            
            render(context) {
                const health = this.getComponent(HealthComponent);
                const isInvulnerable = health.invulnerable;
                
                // Flash when invulnerable
                if (isInvulnerable && Math.floor(Date.now() / 100) % 2) {
                    context.globalAlpha = 0.5;
                }
                
                const renderer = this.game.getSystem('renderer');
                renderer.drawRect(0, 0, this.width, this.height, '#4CAF50');
                
                // Draw health bar
                const healthPercent = health.getHealthPercent();
                renderer.drawRect(0, -10, this.width, 4, '#ff0000');
                renderer.drawRect(0, -10, this.width * healthPercent, 4, '#00ff00');
                
                context.globalAlpha = 1;
            }
        }

        class Enemy extends BaseEntity {
            constructor(x, y) {
                super({
                    x: x,
                    y: y,
                    width: 24,
                    height: 24,
                    type: 'enemy'
                });
                
                this.addComponent(new PhysicsComponent({
                    useGravity: true,
                    maxVelocityX: 100,
                    drag: 0.9
                }));
                
                this.addComponent(new HealthComponent({
                    maxHealth: 30,
                    onDeath: () => {
                        const particles = this.game.getSystem('particles');
                        particles.createEffect('explosion', this.x + this.width/2, this.y + this.height/2);
                        this.destroy();
                    }
                }));
                
                this.direction = Math.random() < 0.5 ? -1 : 1;
                this.moveSpeed = 50;
                this.changeDirectionTimer = 0;
            }
            
            update(deltaTime) {
                super.update(deltaTime);
                
                const physics = this.getComponent(PhysicsComponent);
                
                // Simple AI - change direction occasionally
                this.changeDirectionTimer += deltaTime;
                if (this.changeDirectionTimer > 2) {
                    this.direction *= -1;
                    this.changeDirectionTimer = 0;
                }
                
                physics.velocity.x = this.direction * this.moveSpeed;
                
                // Check collision with player
                const players = this.game.getEntitiesByType('player');
                players.forEach(player => {
                    if (this.checkCollision(player)) {
                        const health = player.getComponent(HealthComponent);
                        health.takeDamage(10);
                    }
                });
                
                // Check collision with bullets
                const bullets = this.game.getEntitiesByType('bullet');
                bullets.forEach(bullet => {
                    if (this.checkCollision(bullet)) {
                        const health = this.getComponent(HealthComponent);
                        health.takeDamage(25);
                        bullet.destroy();
                    }
                });
            }
            
            checkCollision(other) {
                return this.x < other.x + other.width &&
                       this.x + this.width > other.x &&
                       this.y < other.y + other.height &&
                       this.y + this.height > other.y;
            }
            
            render(context) {
                const renderer = this.game.getSystem('renderer');
                renderer.drawRect(0, 0, this.width, this.height, '#f44336');
            }
        }

        class Bullet extends BaseEntity {
            constructor(x, y) {
                super({
                    x: x,
                    y: y,
                    width: 8,
                    height: 4,
                    type: 'bullet'
                });
                
                this.addComponent(new PhysicsComponent({
                    useGravity: false,
                    maxVelocityX: 500
                }));
                
                const physics = this.getComponent(PhysicsComponent);
                physics.velocity.x = 400;
                
                this.lifetime = 3; // seconds
            }
            
            update(deltaTime) {
                super.update(deltaTime);
                
                this.lifetime -= deltaTime;
                if (this.lifetime <= 0) {
                    this.destroy();
                }
                
                // Create trail particles
                if (Math.random() < 0.3) {
                    const particles = this.game.getSystem('particles');
                    particles.emit({
                        position: { x: this.x, y: this.y + this.height/2 },
                        count: 1,
                        speed: 30,
                        lifetime: 20,
                        color: '#ffaa00',
                        size: 2,
                        gravity: 0
                    });
                }
            }
            
            render(context) {
                const renderer = this.game.getSystem('renderer');
                renderer.drawRect(0, 0, this.width, this.height, '#ffff00');
            }
        }

        class Platform extends BaseEntity {
            constructor(x, y, width, height) {
                super({
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    type: 'platform'
                });
            }
            
            render(context) {
                const renderer = this.game.getSystem('renderer');
                renderer.drawRect(0, 0, this.width, this.height, '#795548');
            }
        }

        // Game Scene
        class GameplayScene extends Scene {
            constructor() {
                super('gameplay');
                this.score = 0;
                this.enemySpawnTimer = 0;
                this.enemySpawnRate = 3;
                this.assetsLoaded = 0;
                this.totalAssets = 5;
            }
            
            async onLoad() {
                this.updateLoadingSummary('Loading game assets...');
                
                // Attempt to load game assets
                const assetPromises = [
                    this.game.loadSprite('player', 'karateguy.json').catch(e => ({ error: e.message, id: 'player' })),
                    this.game.loadSprite('enemy', 'enemy.json').catch(e => ({ error: e.message, id: 'enemy' })),
                    this.game.loadAudio('jump', 'jump.wav', 'sfx').catch(e => ({ error: e.message, id: 'jump' })),
                    this.game.loadAudio('shoot', 'shoot.wav', 'sfx').catch(e => ({ error: e.message, id: 'shoot' })),
                    this.game.loadAudio('bgm', 'background.mp3', 'music').catch(e => ({ error: e.message, id: 'bgm' }))
                ];
                
                const results = await Promise.allSettled(assetPromises);
                
                // Count successful loads
                let successCount = 0;
                let failCount = 0;
                
                results.forEach((result, index) => {
                    if (result.status === 'fulfilled' && result.value.loaded !== false) {
                        successCount++;
                    } else {
                        failCount++;
                    }
                });
                
                this.updateLoadingSummary(`Asset loading complete: ${successCount} loaded, ${failCount} failed`);
                
                // Setup particle effects
                const particles = this.game.getSystem('particles');
                
                particles.registerEffect('explosion', {
                    count: 15,
                    speed: 80,
                    lifetime: 30,
                    color: '#ff6600',
                    size: 6,
                    gravity: 200,
                    spread: Math.PI * 2
                });
                
                particles.registerEffect('jump', {
                    count: 8,
                    speed: 50,
                    lifetime: 20,
                    color: '#4CAF50',
                    size: 3,
                    gravity: 100,
                    spread: Math.PI * 0.5
                });
                
                particles.registerEffect('muzzle', {
                    count: 5,
                    speed: 60,
                    lifetime: 15,
                    color: '#ffaa00',
                    size: 4,
                    gravity: 0,
                    spread: Math.PI * 0.3
                });
                
                // Create player
                const player = new Player(100, 400);
                this.game.addEntity(player);
                
                // Create platforms
                this.createPlatforms();
                
                // Create some initial enemies
                for (let i = 0; i < 3; i++) {
                    const enemy = new Enemy(300 + i * 120, 400);
                    this.game.addEntity(enemy);
                }
                
                // Setup camera
                const camera = this.game.getSystem('camera');
                camera.follow(player);
                camera.setBounds(0, 0, 1200, 600);
                
                this.updateLoadingSummary(`Scene loaded successfully! Game ready to play.`);
            }
            
            updateLoadingSummary(message) {
                const summaryEl = document.getElementById('summaryText');
                if (summaryEl) {
                    summaryEl.textContent = message;
                }
            }
            
            createPlatforms() {
                // Ground platforms
                this.game.addEntity(new Platform(0, 550, 300, 50));
                this.game.addEntity(new Platform(400, 550, 400, 50));
                this.game.addEntity(new Platform(900, 550, 300, 50));
                
                // Floating platforms
                this.game.addEntity(new Platform(200, 450, 120, 20));
                this.game.addEntity(new Platform(450, 350, 120, 20));
                this.game.addEntity(new Platform(700, 400, 120, 20));
                this.game.addEntity(new Platform(200, 250, 120, 20));
            }
            
            update(deltaTime) {
                // Spawn enemies
                this.enemySpawnTimer += deltaTime;
                if (this.enemySpawnTimer >= this.enemySpawnRate) {
                    const enemy = new Enemy(800 + Math.random() * 200, 400);
                    this.game.addEntity(enemy);
                    this.enemySpawnTimer = 0;
                }
                
                // Count score based on enemies destroyed
                const currentEnemies = this.game.getEntitiesByType('enemy');
                if (currentEnemies.length < 3) {
                    this.score += 10;
                }
            }
            
            render(context) {
                // Draw background
                const renderer = this.game.getSystem('renderer');
                
                // Simple gradient background
                const gradient = context.createLinearGradient(0, 0, 0, 600);
                gradient.addColorStop(0, '#1e3c72');
                gradient.addColorStop(1, '#2a5298');
                context.fillStyle = gradient;
                context.fillRect(-1000, -1000, 3000, 2000);
                
                // Draw UI (not affected by camera)
                context.save();
                context.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
                
                renderer.drawText(`Score: ${this.score}`, 10, 10, {
                    color: '#ffffff',
                    font: '24px Arial'
                });
                
                renderer.drawText('GameFramework Demo - Assets will fail to load in this environment', 10, 40, {
                    color: '#4CAF50',
                    font: '14px Arial'
                });
                
                context.restore();
            }
        }

        // Initialize and start the game
        async function initGame() {
            const game = new GameFramework({
                game: {
                    width: 800,
                    height: 600,
                    backgroundColor: '#2a2a2a',
                    debug: true
                },
                input: {
                    keyboard: {
                        left: ['ArrowLeft', 'KeyA'],
                        right: ['ArrowRight', 'KeyD'],
                        up: ['ArrowUp', 'KeyW'],
                        down: ['ArrowDown', 'KeyS'],
                        jump: ['Space'],
                        shoot: ['KeyX'],
                        restart: ['KeyR']
                    }
                },
                physics: {
                    gravity: 800,
                    friction: 0.1
                }
            });
            
            await game.initialize('gameCanvas');
            
            const gameplayScene = new GameplayScene();
            game.registerScene('gameplay', gameplayScene);
            
            await game.loadScene('gameplay');
            game.start();
            
            // Add some event listeners for demonstration
            game.events.on('entity:damage', (data) => {
                console.log(`${data.entity.type} took ${data.amount} damage, health: ${data.health}`);
            });
            
            game.events.on('asset:loaded', (data) => {
                console.log(`Asset loaded: ${data.type} - ${data.id}`);
            });
            
            console.log('🎮 Game started! Use arrow keys/WASD to move, Space to jump, X to shoot, R to restart');
            
            return game;
        }
        
        // Start the game when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>