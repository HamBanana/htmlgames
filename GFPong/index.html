<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Character Pong - GameFramework Demo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: white;
        }
        
        #gameContainer {
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }
        
        #gameCanvas {
            border: 3px solid #00ffff;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            background: #0a0a0a;
        }
        
        .game-info {
            margin: 10px 0;
            font-size: 18px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        .controls {
            margin-top: 15px;
            font-size: 14px;
            opacity: 0.8;
        }
        
        .loading {
            color: #00ffff;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1 style="margin: 0 0 20px 0; color: #00ffff; text-shadow: 0 0 15px #00ffff;">⚔️ CHARACTER PONG ⚔️</h1>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="game-info">
            <span id="gameStatus" class="loading">Loading GameFramework...</span>
        </div>
        <div class="controls">
            <strong>Player 1 (Karate Guy):</strong> W/S keys<br>
            <strong>Player 2 (Ninja):</strong> ↑/↓ keys<br>
            <strong>Reset:</strong> R key | <strong>Pause:</strong> Space
        </div>
    </div>

    <!-- Load GameFramework -->
    <script src="/GameFramework/framework-config.js"></script>
    <script src="/GameFramework/index.js"></script>
    
    <script>
        let game;
        let gameState = 'loading';
        let player1, player2, ball;
        let player1Score = 0, player2Score = 0;
        let ballSpeed = 200;
        let paddleSpeed = 300;
        let gameStarted = false;

        // Wait for framework to be ready before defining game classes
        function initializeGameClasses() {
            // Game entities
            window.PongPaddle = class extends BaseEntity {
                constructor(config) {
                    super({
                        type: 'paddle',
                        width: 32,
                        height: 64,
                        ...config
                    });
                    
                    this.playerNumber = config.playerNumber;
                    this.speed = config.speed || 300;
                    this.bounds = config.bounds || { top: 0, bottom: 600 };
                    
                    // Add sprite component
                    this.addComponent(new SpriteComponent(config.spriteName));
                    
                    // Add animation component
                    this.addComponent(new AnimationComponent({
                        autoLoadAnimations: true
                    }));
                    
                    // Add physics for collision
                    this.addComponent(new PhysicsComponent({
                        useGravity: false
                    }));
                    
                    // Add collision
                    this.addComponent(new CollisionComponent({
                        width: this.width,
                        height: this.height
                    }));
                    
                    this.direction = 0; // -1 up, 0 stopped, 1 down
                }
                
                update(deltaTime) {
                    super.update(deltaTime);
                    
                    // Handle input
                    const input = game.getSystem('input');
                    if (input) {
                        if (this.playerNumber === 1) {
                            if (input.isActionPressed('p1up')) {
                                this.direction = -1;
                            } else if (input.isActionPressed('p1down')) {
                                this.direction = 1;
                            } else {
                                this.direction = 0;
                            }
                        } else if (this.playerNumber === 2) {
                            if (input.isActionPressed('p2up')) {
                                this.direction = -1;
                            } else if (input.isActionPressed('p2down')) {
                                this.direction = 1;
                            } else {
                                this.direction = 0;
                            }
                        }
                    }
                    
                    // Move paddle
                    this.y += this.direction * this.speed * deltaTime;
                    
                    // Keep in bounds
                    this.y = Math.max(this.bounds.top, Math.min(this.bounds.bottom - this.height, this.y));
                    
                    // Update animation
                    const animation = this.getComponent(AnimationComponent);
                    if (animation) {
                        if (this.direction !== 0) {
                            animation.play('walk');
                        } else {
                            animation.play('idle');
                        }
                    }
                }
            };

            window.PongBall = class extends BaseEntity {
                constructor(config) {
                    super({
                        type: 'ball',
                        width: 16,
                        height: 16,
                        x: 400,
                        y: 300,
                        ...config
                    });
                    
                    this.speed = config.speed || 200;
                    this.velocity = { x: 0, y: 0 };
                    this.resetBall();
                    
                    // Add physics
                    this.addComponent(new PhysicsComponent({
                        useGravity: false,
                        vx: this.velocity.x,
                        vy: this.velocity.y
                    }));
                    
                    // Add collision
                    this.addComponent(new CollisionComponent({
                        width: this.width,
                        height: this.height
                    }));
                }
                
                resetBall() {
                    this.x = 400;
                    this.y = 300;
                    
                    // Random direction
                    const angle = (Math.random() - 0.5) * Math.PI * 0.5; // ±45 degrees
                    const direction = Math.random() < 0.5 ? -1 : 1;
                    
                    this.velocity.x = Math.cos(angle) * this.speed * direction;
                    this.velocity.y = Math.sin(angle) * this.speed;
                    
                    const physics = this.getComponent(PhysicsComponent);
                    if (physics) {
                        physics.velocity.x = this.velocity.x;
                        physics.velocity.y = this.velocity.y;
                    }
                }
                
                update(deltaTime) {
                    super.update(deltaTime);
                    
                    const physics = this.getComponent(PhysicsComponent);
                    if (!physics) return;
                    
                    // Update position
                    this.x += physics.velocity.x * deltaTime;
                    this.y += physics.velocity.y * deltaTime;
                    
                    // Bounce off top and bottom walls
                    if (this.y <= 0 || this.y >= 600 - this.height) {
                        physics.velocity.y = -physics.velocity.y;
                        this.y = Math.max(0, Math.min(600 - this.height, this.y));
                        game.playSound('bounce');
                        game.createParticleEffect('sparkle', this.x + this.width/2, this.y + this.height/2);
                    }
                    
                    // Check for scoring
                    if (this.x < -50) {
                        // Player 2 scores
                        player2Score++;
                        updateScore();
                        this.resetBall();
                        game.playSound('score');
                        game.createParticleEffect('explosion', 400, 300);
                    } else if (this.x > 850) {
                        // Player 1 scores
                        player1Score++;
                        updateScore();
                        this.resetBall();
                        game.playSound('score');
                        game.createParticleEffect('explosion', 400, 300);
                    }
                    
                    // Check collision with paddles
                    this.checkPaddleCollision(player1);
                    this.checkPaddleCollision(player2);
                }
                
                checkPaddleCollision(paddle) {
                    if (!paddle) return;
                    
                    // Simple AABB collision
                    if (this.x < paddle.x + paddle.width &&
                        this.x + this.width > paddle.x &&
                        this.y < paddle.y + paddle.height &&
                        this.y + this.height > paddle.y) {
                        
                        const physics = this.getComponent(PhysicsComponent);
                        if (!physics) return;
                        
                        // Calculate collision point for angle
                        const paddleCenter = paddle.y + paddle.height / 2;
                        const ballCenter = this.y + this.height / 2;
                        const relativeIntersectY = (ballCenter - paddleCenter) / (paddle.height / 2);
                        
                        // Bounce angle based on where ball hits paddle
                        const bounceAngle = relativeIntersectY * Math.PI / 4; // Max 45 degrees
                        
                        // Increase speed slightly each hit
                        const currentSpeed = Math.sqrt(physics.velocity.x * physics.velocity.x + physics.velocity.y * physics.velocity.y);
                        const newSpeed = Math.min(currentSpeed * 1.05, 400);
                        
                        // Set new velocity
                        physics.velocity.x = Math.cos(bounceAngle) * newSpeed * (physics.velocity.x > 0 ? -1 : 1);
                        physics.velocity.y = Math.sin(bounceAngle) * newSpeed;
                        
                        // Move ball away from paddle to prevent sticking
                        if (paddle.playerNumber === 1) {
                            this.x = paddle.x + paddle.width + 1;
                        } else {
                            this.x = paddle.x - this.width - 1;
                        }
                        
                        game.playSound('paddle');
                        game.createParticleEffect('hit', this.x + this.width/2, this.y + this.height/2);
                        
                        // Trigger paddle animation
                        const animation = paddle.getComponent(AnimationComponent);
                        if (animation) {
                            animation.play('punch');
                        }
                    }
                }
                
                render(context) {
                    // Draw ball as a glowing circle
                    context.save();
                    context.fillStyle = '#00ffff';
                    context.shadowColor = '#00ffff';
                    context.shadowBlur = 10;
                    context.beginPath();
                    context.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI * 2);
                    context.fill();
                    context.restore();
                }
            };
        }

        function updateScore() {
            const status = document.getElementById('gameStatus');
            status.innerHTML = `🥋 Player 1: ${player1Score} | Player 2: ${player2Score} 🥷`;
            status.className = '';
            
            // Check for winner
            if (player1Score >= 5) {
                status.innerHTML += '<br><span style="color: #00ff00;">🏆 KARATE GUY WINS! 🏆</span>';
            } else if (player2Score >= 5) {
                status.innerHTML += '<br><span style="color: #00ff00;">🏆 NINJA WINS! 🏆</span>';
            }
        }

        function drawCenterLine(context) {
            context.save();
            context.strokeStyle = '#333333';
            context.lineWidth = 2;
            context.setLineDash([20, 10]);
            context.beginPath();
            context.moveTo(400, 0);
            context.lineTo(400, 600);
            context.stroke();
            context.restore();
        }

        function resetGame() {
            player1Score = 0;
            player2Score = 0;
            updateScore();
            if (ball) {
                ball.resetBall();
            }
        }

        // Initialize game when framework is ready
        window.addEventListener('gameframework:ready', async () => {
            try {
                document.getElementById('gameStatus').textContent = 'Initializing game...';
                
                // Initialize game classes now that framework is ready
                initializeGameClasses();
                
                // Create game instance
                game = new GameFramework.Game({
                    width: 800,
                    height: 600,
                    backgroundColor: '#0a0a0a',
                    canvasId: 'gameCanvas'
                });
                
                await game.ready;
                
                document.getElementById('gameStatus').textContent = 'Loading sprites...';
                
                // Load sprites
                await game.loadSprite('karateguy', 'karateguy.json');
                await game.loadSprite('ninjamand', 'ninjamand.json');
                
                document.getElementById('gameStatus').textContent = 'Creating players...';
                
                // Create players
                player1 = new PongPaddle({
                    x: 50,
                    y: 268,
                    playerNumber: 1,
                    spriteName: 'karateguy',
                    speed: paddleSpeed,
                    bounds: { top: 0, bottom: 600 }
                });
                
                player2 = new PongPaddle({
                    x: 718,
                    y: 268,
                    playerNumber: 2,
                    spriteName: 'ninjamand',
                    speed: paddleSpeed,
                    bounds: { top: 0, bottom: 600 }
                });
                
                // Create ball
                ball = new PongBall({
                    speed: ballSpeed
                });
                
                // Add entities to game
                game.addEntity(player1);
                game.addEntity(player2);
                game.addEntity(ball);
                
                // Handle input
                const input = game.getSystem('input');
                if (input) {
                    // Add custom key handlers for reset and pause
                    document.addEventListener('keydown', (e) => {
                        if (e.code === 'KeyR') {
                            resetGame();
                        } else if (e.code === 'Space') {
                            e.preventDefault();
                            if (game.paused) {
                                game.resume();
                            } else {
                                game.pause();
                            }
                        }
                    });
                }
                
                // Custom render for UI elements
                game.events.on('game:render', () => {
                    const renderer = game.getSystem('renderer');
                    if (renderer) {
                        drawCenterLine(renderer.context);
                    }
                });
                
                // Initialize score display
                updateScore();
                
                // Start the game
                game.start();
                gameStarted = true;
                
                console.log('🎮 Character Pong game started!');
                
            } catch (error) {
                console.error('Failed to initialize game:', error);
                document.getElementById('gameStatus').textContent = 'Failed to load game. Check console for details.';
            }
        });

        // Handle framework loading errors
        window.addEventListener('gameframework:error', (e) => {
            console.error('GameFramework error:', e.detail.error);
            document.getElementById('gameStatus').textContent = 'Failed to load GameFramework. Check console for details.';
        });

        // Fallback if framework doesn't load
        setTimeout(() => {
            if (!gameStarted) {
                document.getElementById('gameStatus').textContent = 'GameFramework taking too long to load. Please refresh the page.';
            }
        }, 10000);
    </script>
</body>
</html>