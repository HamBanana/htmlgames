<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Beast Busters - Rail Shooter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            cursor: crosshair;
        }
        
        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            position: relative;
            z-index: 1;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        #ui > * {
            pointer-events: auto;
        }
        
        #hud {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            height: 80px;
            background: linear-gradient(to bottom, #000 0%, #111 50%, #000 100%);
            border: 3px solid #444;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 20px;
            color: #0f0;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 5px #0f0;
            pointer-events: none;
        }
        
        .hud-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .hud-label {
            font-size: 12px;
            color: #090;
            margin-bottom: 5px;
        }
        
        .hud-value {
            font-size: 20px;
            color: #0f0;
        }
        
        #health-bar {
            width: 150px;
            height: 20px;
            background: #222;
            border: 2px solid #444;
            border-radius: 10px;
            overflow: hidden;
        }
        
        #health-fill {
            height: 100%;
            background: linear-gradient(to right, #f00, #ff0, #0f0);
            transition: width 0.3s;
        }
        
        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            color: #ff0;
            text-shadow: 2px 2px 0 #000, 0 0 10px #ff0;
            pointer-events: none;
        }
        
        #weapon-select {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
        }
        
        .weapon-btn {
            width: 50px;
            height: 50px;
            background: #222;
            border: 3px solid #444;
            border-radius: 5px;
            color: #888;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .weapon-btn.active {
            border-color: #0f0;
            color: #0f0;
            box-shadow: 0 0 10px #0f0;
        }
        
        .weapon-btn:hover {
            border-color: #0f0;
            transform: scale(1.1);
        }
        
        #crosshair {
            position: absolute;
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #f00;
            padding: 30px;
            text-align: center;
            display: none;
            color: #f00;
            font-size: 24px;
            border-radius: 10px;
            z-index: 100;
        }
        
        #gameOver h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #f00;
        }
        
        #gameOver button {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 20px;
            background: #f00;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        #gameOver button:hover {
            background: #ff0;
            transform: scale(1.1);
        }
        
        #instructions {
            position: absolute;
            top: 70px;
            left: 10px;
            color: #888;
            font-size: 12px;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
        }
        
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #000, #001, #010);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #0f0;
            text-align: center;
        }
        
        .title {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #0f0;
            color: #f00;
        }
        
        .subtitle {
            font-size: 24px;
            margin-bottom: 40px;
            text-shadow: 0 0 10px #0f0;
        }
        
        .start-btn {
            padding: 15px 30px;
            font-size: 20px;
            background: #0f0;
            color: #000;
            border: 3px solid #0f0;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
        }
        
        .start-btn:hover {
            background: #000;
            color: #0f0;
            box-shadow: 0 0 20px #0f0;
            transform: scale(1.1);
        }
        
        @media (max-width: 768px) {
            #hud {
                height: 60px;
                padding: 5px 10px;
            }
            
            .hud-label {
                font-size: 10px;
            }
            
            .hud-value {
                font-size: 16px;
            }
            
            #weapon-select {
                top: auto;
                bottom: 100px;
            }
            
            .weapon-btn {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
            
            #instructions {
                display: none;
            }
            
            .title {
                font-size: 32px;
            }
            
            .subtitle {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="startScreen">
        <div class="title">BEAST BUSTERS</div>
        <div class="subtitle">Rail Shooter</div>
        <div style="margin-bottom: 30px; font-size: 14px; color: #888;">
            Eliminate all creatures to survive!<br>
            Mouse/Touch to aim and shoot
        </div>
        <button class="start-btn" id="startBtn">Start Game</button>
    </div>
    
    <div id="ui">
        <div id="score">SCORE: 0</div>
        
        <div id="weapon-select">
            <div class="weapon-btn active" data-weapon="pistol" title="Pistol">ðŸ”«</div>
            <div class="weapon-btn" data-weapon="shotgun" title="Shotgun">ðŸ’¥</div>
            <div class="weapon-btn" data-weapon="machinegun" title="Machine Gun">ðŸ”¥</div>
        </div>
        
        <div id="instructions">
            MOUSE/TOUCH: Aim & Shoot<br>
            1-3: Change Weapon<br>
            Eliminate all enemies!<br>
            <span id="spriteStatus" style="color: #888; font-size: 10px;"></span>
        </div>
        
        <div id="hud">
            <div class="hud-section">
                <div class="hud-label">HEALTH</div>
                <div id="health-bar">
                    <div id="health-fill" style="width: 100%"></div>
                </div>
            </div>
            
            <div class="hud-section">
                <div class="hud-label">AMMO</div>
                <div id="ammo-display">
                    <div class="hud-value" id="ammo-count">âˆž</div>
                </div>
            </div>
            
            <div class="hud-section">
                <div class="hud-label">WAVE</div>
                <div class="hud-value" id="wave">1</div>
            </div>
            
            <div class="hud-section">
                <div class="hud-label">ENEMIES</div>
                <div class="hud-value" id="enemies-left">0</div>
            </div>
        </div>
        
        <div id="crosshair">
            <svg width="40" height="40">
                <circle cx="20" cy="20" r="18" fill="none" stroke="#0f0" stroke-width="2" opacity="0.8"/>
                <line x1="20" y1="5" x2="20" y2="35" stroke="#0f0" stroke-width="2"/>
                <line x1="5" y1="20" x2="35" y2="20" stroke="#0f0" stroke-width="2"/>
                <circle cx="20" cy="20" r="3" fill="#f00"/>
            </svg>
        </div>
        
        <div id="gameOver">
            <h1>GAME OVER</h1>
            <div>Final Score: <span id="finalScore">0</span></div>
            <div>Wave Reached: <span id="finalWave">1</span></div>
            <button id="restartBtn">Play Again</button>
        </div>
    </div>

    <script>
        // Sprite loading and management
        class SpriteLoader {
            constructor() {
                this.sprites = new Map();
                this.images = new Map();
            }
            
            async loadSprite(name, imagePath) {
                try {
                    const image = new Image();
                    image.src = `../GameDevStuff/Assets/Sprites/${imagePath}`;
                    
                    return new Promise((resolve, reject) => {
                        image.onload = () => {
                            this.images.set(name, image);
                            
                            // Create sprite data - assuming simple single frame for now
                            const spriteData = {
                                image: image,
                                width: image.width,
                                height: image.height,
                                frames: [{
                                    x: 0, y: 0,
                                    width: image.width,
                                    height: image.height
                                }]
                            };
                            
                            this.sprites.set(name, spriteData);
                            resolve(spriteData);
                        };
                        
                        image.onerror = () => {
                            console.warn(`Failed to load sprite: ${imagePath}, using fallback`);
                            // Create a fallback colored square
                            const canvas = document.createElement('canvas');
                            canvas.width = 64;
                            canvas.height = 64;
                            const ctx = canvas.getContext('2d');
                            
                            // Different colors for different sprite names
                            ctx.fillStyle = name === 'karateguy' ? '#0a0' : 
                                           name === 'ninjamand' ? '#808' : '#f00';
                            ctx.fillRect(0, 0, 64, 64);
                            
                            // Add simple face
                            ctx.fillStyle = '#f00';
                            ctx.fillRect(16, 20, 8, 8); // left eye
                            ctx.fillRect(40, 20, 8, 8); // right eye
                            ctx.fillRect(24, 40, 16, 4); // mouth
                            
                            const spriteData = {
                                image: canvas,
                                width: 64,
                                height: 64,
                                frames: [{
                                    x: 0, y: 0,
                                    width: 64,
                                    height: 64
                                }]
                            };
                            
                            this.sprites.set(name, spriteData);
                            resolve(spriteData);
                        };
                    });
                    
                } catch (error) {
                    console.error(`Error loading sprite ${name}:`, error);
                    throw error;
                }
            }
            
            getSprite(name) {
                return this.sprites.get(name);
            }
            
            drawSprite(ctx, name, x, y, scale = 1, frame = 0) {
                const sprite = this.sprites.get(name);
                if (!sprite) return false;
                
                const frameData = sprite.frames[frame % sprite.frames.length];
                const width = frameData.width * scale;
                const height = frameData.height * scale;
                
                ctx.drawImage(
                    sprite.image,
                    frameData.x, frameData.y,
                    frameData.width, frameData.height,
                    x - width/2, y - height/2,
                    width, height
                );
                
                return true;
            }
        }
        
        // Simple 3D rail shooter with sprite support
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.running = false;
                this.paused = false;
                this.spritesLoaded = false;
                
                // Initialize sprite loader
                this.spriteLoader = new SpriteLoader();
                
                // Game state
                this.score = 0;
                this.wave = 1;
                this.playerHealth = 100;
                this.maxHealth = 100;
                this.currentWeapon = 'pistol';
                this.ammo = { shotgun: 50, machinegun: 200 };
                
                // Input
                this.mouseX = 0;
                this.mouseY = 0;
                this.shooting = false;
                this.keys = {};
                
                // Game objects
                this.enemies = [];
                this.bullets = [];
                this.particles = [];
                this.powerups = [];
                
                // Timing
                this.lastTime = 0;
                this.fireTimer = 0;
                this.waveTimer = 0;
                this.waveDelay = 3;
                this.enemiesInWave = 0;
                this.enemiesKilled = 0;
                
                // Weapons
                this.weapons = {
                    pistol: { damage: 30, fireRate: 3, ammo: Infinity, spread: 0 },
                    shotgun: { damage: 20, fireRate: 1, ammo: 50, spread: 0.3, pellets: 5 },
                    machinegun: { damage: 15, fireRate: 10, ammo: 200, spread: 0.1 }
                };
                
                // Camera shake
                this.shakeX = 0;
                this.shakeY = 0;
                this.shakeIntensity = 0;
                
                this.setupCanvas();
                this.setupEvents();
                this.showStartScreen();
            }
            
            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.ctx.imageSmoothingEnabled = false;
            }
            
            setupEvents() {
                // Mouse/touch controls
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouseX = e.clientX - rect.left;
                    this.mouseY = e.clientY - rect.top;
                    this.updateCrosshair(e.clientX, e.clientY);
                });
                
                this.canvas.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.shooting = true;
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.shooting = false;
                });
                
                // Touch events
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.shooting = true;
                    this.handleTouch(e);
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.handleTouch(e);
                });
                
                this.canvas.addEventListener('touchend', () => {
                    this.shooting = false;
                });
                
                // Keyboard
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                    if (e.key >= '1' && e.key <= '3') {
                        const weapons = ['pistol', 'shotgun', 'machinegun'];
                        this.selectWeapon(weapons[parseInt(e.key) - 1]);
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });
                
                // Weapon selection
                document.querySelectorAll('.weapon-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.selectWeapon(btn.dataset.weapon);
                    });
                });
                
                // Start and restart buttons
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.startGame();
                });
                
                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.restartGame();
                });
                
                // Resize handling
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                });
                
                // Show crosshair
                document.getElementById('crosshair').style.display = 'block';
            }
            
            handleTouch(e) {
                const rect = this.canvas.getBoundingClientRect();
                const touch = e.touches[0];
                this.mouseX = touch.clientX - rect.left;
                this.mouseY = touch.clientY - rect.top;
                this.updateCrosshair(touch.clientX, touch.clientY);
            }
            
            updateCrosshair(clientX, clientY) {
                const crosshair = document.getElementById('crosshair');
                crosshair.style.left = clientX - 20 + 'px';
                crosshair.style.top = clientY - 20 + 'px';
            }
            
            async loadSprites() {
                try {
                    document.getElementById('startBtn').textContent = 'Loading Sprites...';
                    document.getElementById('startBtn').disabled = true;
                    
                    const statusEl = document.getElementById('spriteStatus');
                    if (statusEl) statusEl.textContent = 'Loading karateguy sprite...';
                    
                    // Try to load sprites with various file extensions
                    const extensions = ['png', 'jpg', 'gif'];
                    
                    for (let ext of extensions) {
                        try {
                            await this.spriteLoader.loadSprite('karateguy', `karateguy.${ext}`);
                            if (statusEl) statusEl.textContent = 'Karateguy loaded! Loading ninjamand...';
                            break;
                        } catch (e) {
                            if (ext === extensions[extensions.length - 1]) {
                                // Last extension failed, use fallback
                                await this.spriteLoader.loadSprite('karateguy', 'karateguy.png');
                                if (statusEl) statusEl.textContent = 'Karateguy fallback loaded! Loading ninjamand...';
                            }
                        }
                    }
                    
                    for (let ext of extensions) {
                        try {
                            await this.spriteLoader.loadSprite('ninjamand', `ninjamand.${ext}`);
                            if (statusEl) statusEl.textContent = 'All sprites loaded!';
                            break;
                        } catch (e) {
                            if (ext === extensions[extensions.length - 1]) {
                                // Last extension failed, use fallback
                                await this.spriteLoader.loadSprite('ninjamand', 'ninjamand.png');
                                if (statusEl) statusEl.textContent = 'All sprites loaded (with fallbacks)!';
                            }
                        }
                    }
                    
                    this.spritesLoaded = true;
                    document.getElementById('startBtn').textContent = 'Start Game';
                    document.getElementById('startBtn').disabled = false;
                    
                    setTimeout(() => {
                        if (statusEl) statusEl.textContent = '';
                    }, 2000);
                    
                } catch (error) {
                    console.error('Error loading sprites:', error);
                    this.spritesLoaded = true; // Use fallbacks
                    document.getElementById('startBtn').textContent = 'Start Game';
                    document.getElementById('startBtn').disabled = false;
                    
                    const statusEl = document.getElementById('spriteStatus');
                    if (statusEl) statusEl.textContent = 'Using fallback graphics';
                }
            }
            
            showStartScreen() {
                document.getElementById('startScreen').style.display = 'flex';
                this.loadSprites(); // Load sprites when showing start screen
            }
            
            startGame() {
                if (!this.spritesLoaded) {
                    console.log('Sprites not loaded yet, please wait...');
                    return;
                }
                
                document.getElementById('startScreen').style.display = 'none';
                this.running = true;
                this.lastTime = performance.now();
                this.spawnWave();
                this.gameLoop();
            }
            
            restartGame() {
                // Reset game state
                this.score = 0;
                this.wave = 1;
                this.playerHealth = 100;
                this.ammo = { shotgun: 50, machinegun: 200 };
                this.currentWeapon = 'pistol';
                
                // Clear arrays
                this.enemies = [];
                this.bullets = [];
                this.particles = [];
                this.powerups = [];
                
                // Reset timers
                this.waveTimer = 0;
                this.enemiesInWave = 0;
                this.enemiesKilled = 0;
                
                // Update UI
                this.updateUI();
                this.selectWeapon('pistol');
                
                // Hide game over screen
                document.getElementById('gameOver').style.display = 'none';
                
                // Start game
                this.startGame();
            }
            
            selectWeapon(weapon) {
                // Check ammo for limited weapons
                if ((weapon === 'shotgun' && this.ammo.shotgun <= 0) ||
                    (weapon === 'machinegun' && this.ammo.machinegun <= 0)) {
                    return;
                }
                
                this.currentWeapon = weapon;
                
                // Update UI
                document.querySelectorAll('.weapon-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.weapon === weapon);
                });
                
                this.updateAmmoDisplay();
            }
            
            updateAmmoDisplay() {
                const ammoCount = document.getElementById('ammo-count');
                if (this.currentWeapon === 'pistol') {
                    ammoCount.textContent = 'âˆž';
                } else {
                    ammoCount.textContent = this.ammo[this.currentWeapon];
                }
            }
            
            gameLoop() {
                if (!this.running) return;
                
                const currentTime = performance.now();
                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;
                
                this.update(deltaTime);
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
            
            update(deltaTime) {
                if (this.paused) return;
                
                // Update timers
                this.fireTimer = Math.max(0, this.fireTimer - deltaTime);
                this.waveTimer += deltaTime;
                
                // Shooting
                if ((this.shooting || this.keys[' ']) && this.fireTimer <= 0) {
                    this.fire();
                }
                
                // Update shake
                if (this.shakeIntensity > 0) {
                    this.shakeX = (Math.random() - 0.5) * this.shakeIntensity;
                    this.shakeY = (Math.random() - 0.5) * this.shakeIntensity;
                    this.shakeIntensity *= 0.9;
                    if (this.shakeIntensity < 0.5) {
                        this.shakeIntensity = 0;
                        this.shakeX = 0;
                        this.shakeY = 0;
                    }
                }
                
                // Update bullets
                this.bullets = this.bullets.filter(bullet => {
                    bullet.x += bullet.vx * deltaTime;
                    bullet.y += bullet.vy * deltaTime;
                    bullet.z += bullet.vz * deltaTime;
                    bullet.life -= deltaTime;
                    
                    // Check collision with enemies
                    for (let enemy of this.enemies) {
                        const dx = bullet.x - enemy.x;
                        const dy = bullet.y - enemy.y;
                        const dz = bullet.z - enemy.z;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        if (dist < 50) {
                            this.hitEnemy(enemy, bullet.damage);
                            this.createHitEffect(bullet.x, bullet.y, bullet.z);
                            return false; // Remove bullet
                        }
                    }
                    
                    return bullet.life > 0 && bullet.z > -1000;
                });
                
                // Update enemies
                this.enemies.forEach(enemy => {
                    // Move towards player
                    enemy.z += enemy.speed * deltaTime;
                    enemy.x += Math.sin(enemy.z * 0.01 + enemy.offset) * enemy.sway;
                    
                    // Update animation
                    enemy.animTimer += deltaTime;
                    if (enemy.animTimer > 0.2) { // Change frame every 0.2 seconds
                        enemy.animTimer = 0;
                        enemy.animFrame = (enemy.animFrame + 1) % 4; // Assume 4 frames max
                    }
                    
                    // Attack player if close
                    if (enemy.z > -100 && !enemy.hasAttacked) {
                        enemy.hasAttacked = true;
                        this.takeDamage(enemy.damage);
                    }
                    
                    // Update screen position
                    this.updateEnemyScreenPos(enemy);
                });
                
                // Remove enemies that are too close or dead
                this.enemies = this.enemies.filter(enemy => 
                    enemy.health > 0 && enemy.z < 100
                );
                
                // Update particles
                this.particles = this.particles.filter(particle => {
                    particle.x += particle.vx * deltaTime;
                    particle.y += particle.vy * deltaTime;
                    particle.life -= deltaTime;
                    particle.alpha = particle.life / particle.maxLife;
                    return particle.life > 0;
                });
                
                // Update powerups
                this.powerups.forEach(powerup => {
                    powerup.z += 50 * deltaTime;
                    powerup.bobOffset += deltaTime * 5;
                    powerup.y = powerup.baseY + Math.sin(powerup.bobOffset) * 20;
                    
                    // Check collection
                    if (powerup.z > -100) {
                        const dist = Math.sqrt(powerup.x * powerup.x + powerup.y * powerup.y);
                        if (dist < 100) {
                            this.collectPowerup(powerup);
                            powerup.collected = true;
                        }
                    }
                    
                    this.updateEnemyScreenPos(powerup);
                });
                
                this.powerups = this.powerups.filter(p => !p.collected && p.z < 200);
                
                // Check wave completion
                if (this.enemies.length === 0 && this.enemiesKilled >= this.enemiesInWave && this.waveTimer > this.waveDelay) {
                    this.nextWave();
                }
                
                this.updateUI();
            }
            
            fire() {
                const weapon = this.weapons[this.currentWeapon];
                
                // Check ammo
                if (this.currentWeapon !== 'pistol' && this.ammo[this.currentWeapon] <= 0) {
                    this.selectWeapon('pistol');
                    return;
                }
                
                this.fireTimer = 1 / weapon.fireRate;
                
                // Calculate aim direction
                const aimX = (this.mouseX - this.canvas.width / 2) * 2;
                const aimY = (this.mouseY - this.canvas.height / 2) * 2;
                
                // Fire projectiles
                const pellets = weapon.pellets || 1;
                for (let i = 0; i < pellets; i++) {
                    const spread = weapon.spread * (Math.random() - 0.5);
                    const bullet = {
                        x: 0, y: 0, z: -100,
                        vx: aimX + spread * 100,
                        vy: aimY + spread * 100,
                        vz: -800,
                        damage: weapon.damage,
                        life: 2,
                        color: this.currentWeapon === 'machinegun' ? '#ff0' : '#0f0'
                    };
                    this.bullets.push(bullet);
                }
                
                // Consume ammo
                if (this.currentWeapon !== 'pistol') {
                    this.ammo[this.currentWeapon]--;
                }
                
                // Effects
                this.shake(this.currentWeapon === 'shotgun' ? 8 : 3);
                this.createMuzzleFlash();
            }
            
            hitEnemy(enemy, damage) {
                enemy.health -= damage;
                
                if (enemy.health <= 0) {
                    this.score += enemy.score;
                    this.enemiesKilled++;
                    this.createExplosion(enemy.x, enemy.y, enemy.z);
                    
                    // Drop powerup chance
                    if (Math.random() < 0.3) {
                        this.dropPowerup(enemy.x, enemy.y, enemy.z);
                    }
                }
            }
            
            takeDamage(amount) {
                this.playerHealth -= amount;
                this.playerHealth = Math.max(0, this.playerHealth);
                this.shake(15);
                
                if (this.playerHealth <= 0) {
                    this.gameOver();
                }
            }
            
            gameOver() {
                this.running = false;
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('finalWave').textContent = this.wave;
                document.getElementById('gameOver').style.display = 'block';
            }
            
            spawnWave() {
                this.wave++;
                this.waveTimer = 0;
                this.enemiesKilled = 0;
                this.enemiesInWave = Math.min(2 + this.wave, 10);
                
                // Spawn enemies over time
                for (let i = 0; i < this.enemiesInWave; i++) {
                    setTimeout(() => {
                        if (this.running) {
                            this.spawnEnemy();
                        }
                    }, i * 1000);
                }
            }
            
            nextWave() {
                // Brief pause between waves
                this.waveTimer = 0;
                this.waveDelay = 2;
                setTimeout(() => {
                    if (this.running) {
                        this.spawnWave();
                    }
                }, 2000);
            }
            
            spawnEnemy() {
                const types = [
                    { name: 'zombie', sprite: 'karateguy', health: 60, damage: 20, speed: 100, score: 100, flying: false },
                    { name: 'demon', sprite: 'karateguy', health: 80, damage: 25, speed: 80, score: 200, flying: false },
                    { name: 'bat', sprite: 'ninjamand', health: 40, damage: 15, speed: 200, score: 150, flying: true }
                ];
                
                const type = types[Math.floor(Math.random() * types.length)];
                
                const enemy = {
                    type: type.name,
                    sprite: type.sprite,
                    x: (Math.random() - 0.5) * 800,
                    y: type.flying ? -100 - Math.random() * 200 : 0,
                    z: -800 - Math.random() * 400,
                    health: type.health,
                    maxHealth: type.health,
                    damage: type.damage,
                    speed: type.speed,
                    score: type.score,
                    flying: type.flying,
                    sway: type.flying ? 3 : 1,
                    offset: Math.random() * Math.PI * 2,
                    hasAttacked: false,
                    screenX: 0,
                    screenY: 0,
                    scale: 1,
                    visible: false,
                    animFrame: 0,
                    animTimer: 0
                };
                
                this.enemies.push(enemy);
            }
            
            dropPowerup(x, y, z) {
                const types = ['health', 'ammo_shotgun', 'ammo_machinegun'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                const powerup = {
                    type: type,
                    x: x,
                    y: y,
                    z: z,
                    baseY: y,
                    bobOffset: 0,
                    collected: false,
                    screenX: 0,
                    screenY: 0,
                    scale: 1,
                    visible: false
                };
                
                this.powerups.push(powerup);
            }
            
            collectPowerup(powerup) {
                switch (powerup.type) {
                    case 'health':
                        this.playerHealth = Math.min(this.maxHealth, this.playerHealth + 30);
                        break;
                    case 'ammo_shotgun':
                        this.ammo.shotgun = Math.min(50, this.ammo.shotgun + 20);
                        break;
                    case 'ammo_machinegun':
                        this.ammo.machinegun = Math.min(200, this.ammo.machinegun + 50);
                        break;
                }
                
                this.createPickupEffect(powerup.screenX, powerup.screenY);
            }
            
            updateEnemyScreenPos(obj) {
                if (obj.z >= -50) {
                    obj.visible = false;
                    return;
                }
                
                const fov = 800;
                obj.scale = fov / -obj.z;
                obj.screenX = this.canvas.width / 2 + obj.x * obj.scale;
                obj.screenY = this.canvas.height / 2 - obj.y * obj.scale;
                
                const margin = 100;
                obj.visible = obj.screenX > -margin && obj.screenX < this.canvas.width + margin &&
                             obj.screenY > -margin && obj.screenY < this.canvas.height + margin;
            }
            
            shake(intensity) {
                this.shakeIntensity = intensity;
            }
            
            createMuzzleFlash() {
                for (let i = 0; i < 5; i++) {
                    this.particles.push({
                        x: this.canvas.width / 2 + (Math.random() - 0.5) * 20,
                        y: this.canvas.height / 2 + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 100,
                        vy: (Math.random() - 0.5) * 100,
                        life: 0.1,
                        maxLife: 0.1,
                        alpha: 1,
                        size: Math.random() * 10 + 5,
                        color: '#ff0'
                    });
                }
            }
            
            createHitEffect(x, y, z) {
                const fov = 800;
                const scale = fov / -z;
                const screenX = this.canvas.width / 2 + x * scale;
                const screenY = this.canvas.height / 2 - y * scale;
                
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: screenX,
                        y: screenY,
                        vx: (Math.random() - 0.5) * 200,
                        vy: (Math.random() - 0.5) * 200,
                        life: 0.5,
                        maxLife: 0.5,
                        alpha: 1,
                        size: Math.random() * 6 + 3,
                        color: '#f00'
                    });
                }
            }
            
            createExplosion(x, y, z) {
                const fov = 800;
                const scale = fov / -z;
                const screenX = this.canvas.width / 2 + x * scale;
                const screenY = this.canvas.height / 2 - y * scale;
                
                for (let i = 0; i < 15; i++) {
                    this.particles.push({
                        x: screenX,
                        y: screenY,
                        vx: (Math.random() - 0.5) * 300,
                        vy: (Math.random() - 0.5) * 300,
                        life: 1,
                        maxLife: 1,
                        alpha: 1,
                        size: Math.random() * 12 + 8,
                        color: Math.random() > 0.5 ? '#ff0' : '#f80'
                    });
                }
            }
            
            createPickupEffect(x, y) {
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 150,
                        vy: (Math.random() - 0.5) * 150,
                        life: 0.8,
                        maxLife: 0.8,
                        alpha: 1,
                        size: Math.random() * 8 + 4,
                        color: '#0f0'
                    });
                }
            }
            
            updateUI() {
                document.getElementById('score').textContent = `SCORE: ${this.score}`;
                document.getElementById('wave').textContent = this.wave;
                document.getElementById('enemies-left').textContent = Math.max(0, this.enemiesInWave - this.enemiesKilled);
                document.getElementById('health-fill').style.width = (this.playerHealth / this.maxHealth * 100) + '%';
                this.updateAmmoDisplay();
            }
            
            render() {
                // Clear screen
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Apply camera shake
                this.ctx.save();
                this.ctx.translate(this.shakeX, this.shakeY);
                
                this.drawEnvironment();
                this.drawBullets();
                this.drawEnemies();
                this.drawPowerups();
                this.drawParticles();
                
                this.ctx.restore();
            }
            
            drawEnvironment() {
                // Draw starfield/background
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                for (let i = 0; i < 50; i++) {
                    const x = (Math.sin(performance.now() * 0.001 + i) * 0.5 + 0.5) * this.canvas.width;
                    const y = (Math.cos(performance.now() * 0.001 + i * 0.7) * 0.5 + 0.5) * this.canvas.height;
                    this.ctx.fillRect(x, y, 2, 2);
                }
                
                // Draw horizon line
                this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.canvas.height / 2);
                this.ctx.lineTo(this.canvas.width, this.canvas.height / 2);
                this.ctx.stroke();
                
                // Draw perspective grid
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
                this.ctx.lineWidth = 1;
                
                // Vertical lines with perspective
                for (let x = -10; x <= 10; x++) {
                    const screenX = centerX + x * 40;
                    const vanishingOffset = x * 15;
                    this.ctx.beginPath();
                    this.ctx.moveTo(screenX, centerY);
                    this.ctx.lineTo(screenX - vanishingOffset, this.canvas.height);
                    this.ctx.stroke();
                }
                
                // Horizontal lines for depth
                for (let z = 1; z <= 10; z++) {
                    const y = centerY + z * z * 6;
                    const alpha = Math.max(0.05, 0.3 - z * 0.03);
                    this.ctx.strokeStyle = `rgba(0, 255, 0, ${alpha})`;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
                
                // Side walls with depth
                this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.1)';
                this.ctx.lineWidth = 2;
                // Left wall
                this.ctx.beginPath();
                this.ctx.moveTo(0, 0);
                this.ctx.lineTo(centerX - 300, centerY);
                this.ctx.lineTo(centerX - 300, this.canvas.height);
                this.ctx.lineTo(0, this.canvas.height);
                this.ctx.stroke();
                
                // Right wall
                this.ctx.beginPath();
                this.ctx.moveTo(this.canvas.width, 0);
                this.ctx.lineTo(centerX + 300, centerY);
                this.ctx.lineTo(centerX + 300, this.canvas.height);
                this.ctx.lineTo(this.canvas.width, this.canvas.height);
                this.ctx.stroke();
            }
            
            drawBullets() {
                this.bullets.forEach(bullet => {
                    if (bullet.z >= -50) return;
                    
                    const fov = 800;
                    const scale = fov / -bullet.z;
                    const screenX = this.canvas.width / 2 + bullet.x * scale;
                    const screenY = this.canvas.height / 2 - bullet.y * scale;
                    
                    this.ctx.fillStyle = bullet.color;
                    this.ctx.fillRect(screenX - 2, screenY - 2, 4, 4);
                });
            }
            
            drawEnemies() {
                this.enemies.forEach(enemy => {
                    if (!enemy.visible) return;
                    
                    const baseSize = 64; // Base sprite size
                    const size = baseSize * enemy.scale;
                    
                    // Try to draw sprite first
                    const spriteDrawn = this.spriteLoader.drawSprite(
                        this.ctx,
                        enemy.sprite,
                        enemy.screenX,
                        enemy.screenY,
                        enemy.scale,
                        enemy.animFrame
                    );
                    
                    // Fallback to colored rectangle if sprite fails
                    if (!spriteDrawn) {
                        this.ctx.fillStyle = enemy.type === 'demon' ? '#f00' : 
                                            enemy.type === 'bat' ? '#808' : '#0a0';
                        this.ctx.fillRect(
                            enemy.screenX - size/2,
                            enemy.screenY - size/2,
                            size,
                            size
                        );
                        
                        // Eyes
                        this.ctx.fillStyle = '#f00';
                        this.ctx.fillRect(
                            enemy.screenX - size/3,
                            enemy.screenY - size/4,
                            size/6,
                            size/6
                        );
                        this.ctx.fillRect(
                            enemy.screenX + size/6,
                            enemy.screenY - size/4,
                            size/6,
                            size/6
                        );
                    }
                    
                    // Health bar
                    if (enemy.health < enemy.maxHealth) {
                        const barWidth = size;
                        const barHeight = 6;
                        const barY = enemy.screenY - size/2 - 10;
                        
                        this.ctx.fillStyle = '#333';
                        this.ctx.fillRect(enemy.screenX - barWidth/2, barY, barWidth, barHeight);
                        
                        this.ctx.fillStyle = '#f00';
                        const healthPercent = enemy.health / enemy.maxHealth;
                        this.ctx.fillRect(enemy.screenX - barWidth/2, barY, barWidth * healthPercent, barHeight);
                        
                        // Health bar border
                        this.ctx.strokeStyle = '#fff';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(enemy.screenX - barWidth/2, barY, barWidth, barHeight);
                    }
                });
            }
            
            drawPowerups() {
                this.powerups.forEach(powerup => {
                    if (!powerup.visible) return;
                    
                    const size = 30 * powerup.scale;
                    
                    this.ctx.fillStyle = powerup.type === 'health' ? '#0f0' : '#ff0';
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 2;
                    
                    if (powerup.type === 'health') {
                        // Cross
                        this.ctx.fillRect(
                            powerup.screenX - size/2,
                            powerup.screenY - size/6,
                            size,
                            size/3
                        );
                        this.ctx.fillRect(
                            powerup.screenX - size/6,
                            powerup.screenY - size/2,
                            size/3,
                            size
                        );
                    } else {
                        // Box
                        this.ctx.fillRect(
                            powerup.screenX - size/2,
                            powerup.screenY - size/2,
                            size,
                            size
                        );
                        this.ctx.strokeRect(
                            powerup.screenX - size/2,
                            powerup.screenY - size/2,
                            size,
                            size
                        );
                    }
                });
            }
            
            drawParticles() {
                this.particles.forEach(particle => {
                    this.ctx.fillStyle = particle.color;
                    this.ctx.globalAlpha = particle.alpha;
                    this.ctx.fillRect(
                        particle.x - particle.size/2,
                        particle.y - particle.size/2,
                        particle.size,
                        particle.size
                    );
                });
                this.ctx.globalAlpha = 1;
            }
        }
        
        // Start the game
        let game;
        
        window.addEventListener('load', () => {
            game = new Game();
        });
    </script>
</body>
</html>