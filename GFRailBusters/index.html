<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Beast Busters - Rail Shooter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            cursor: crosshair;
        }
        
        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            position: relative;
            z-index: 1;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        #ui > * {
            pointer-events: auto;
        }
        
        #hud {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            height: 80px;
            background: linear-gradient(to bottom, #000 0%, #111 50%, #000 100%);
            border: 3px solid #444;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 20px;
            color: #0f0;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 5px #0f0;
            pointer-events: none;
        }
        
        .hud-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .hud-label {
            font-size: 12px;
            color: #090;
            margin-bottom: 5px;
        }
        
        .hud-value {
            font-size: 20px;
            color: #0f0;
        }
        
        #health-bar {
            width: 150px;
            height: 20px;
            background: #222;
            border: 2px solid #444;
            border-radius: 10px;
            overflow: hidden;
        }
        
        #health-fill {
            height: 100%;
            background: linear-gradient(to right, #f00, #ff0, #0f0);
            transition: width 0.3s;
        }
        
        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            color: #ff0;
            text-shadow: 2px 2px 0 #000, 0 0 10px #ff0;
            pointer-events: none;
        }
        
        #weapon-select {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
        }
        
        .weapon-btn {
            width: 50px;
            height: 50px;
            background: #222;
            border: 3px solid #444;
            border-radius: 5px;
            color: #888;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .weapon-btn.active {
            border-color: #0f0;
            color: #0f0;
            box-shadow: 0 0 10px #0f0;
        }
        
        .weapon-btn:hover {
            border-color: #0f0;
            transform: scale(1.1);
        }
        
        #crosshair {
            position: absolute;
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #f00;
            padding: 30px;
            text-align: center;
            display: none;
            color: #f00;
            font-size: 24px;
            border-radius: 10px;
            z-index: 100;
        }
        
        #gameOver h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #f00;
        }
        
        #gameOver button {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 20px;
            background: #f00;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        #gameOver button:hover {
            background: #ff0;
            transform: scale(1.1);
        }
        
        #instructions {
            position: absolute;
            top: 70px;
            left: 10px;
            color: #888;
            font-size: 12px;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
        }
        
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #000, #001, #010);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #0f0;
            text-align: center;
        }
        
        .title {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #0f0;
            color: #f00;
        }
        
        .subtitle {
            font-size: 24px;
            margin-bottom: 40px;
            text-shadow: 0 0 10px #0f0;
        }
        
        .start-btn {
            padding: 15px 30px;
            font-size: 20px;
            background: #0f0;
            color: #000;
            border: 3px solid #0f0;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
        }
        
        .start-btn:hover {
            background: #000;
            color: #0f0;
            box-shadow: 0 0 20px #0f0;
            transform: scale(1.1);
        }
        
        #loadingStatus {
            color: #ff0;
            font-size: 16px;
            margin-top: 20px;
            min-height: 20px;
        }
        
        @media (max-width: 768px) {
            #hud {
                height: 60px;
                padding: 5px 10px;
            }
            
            .hud-label {
                font-size: 10px;
            }
            
            .hud-value {
                font-size: 16px;
            }
            
            #weapon-select {
                top: auto;
                bottom: 100px;
            }
            
            .weapon-btn {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
            
            #instructions {
                display: none;
            }
            
            .title {
                font-size: 32px;
            }
            
            .subtitle {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="startScreen">
        <div class="title">BEAST BUSTERS</div>
        <div class="subtitle">Rail Shooter</div>
        <div style="margin-bottom: 30px; font-size: 14px; color: #888;">
            Eliminate all creatures to survive!<br>
            Mouse/Touch to aim and shoot
        </div>
        <button class="start-btn" id="startBtn" disabled>Loading Framework...</button>
        <div id="loadingStatus">Initializing GameFramework...</div>
    </div>
    
    <div id="ui">
        <div id="score">SCORE: 0</div>
        
        <div id="weapon-select">
            <div class="weapon-btn active" data-weapon="pistol" title="Pistol">🔫</div>
            <div class="weapon-btn" data-weapon="shotgun" title="Shotgun">💥</div>
            <div class="weapon-btn" data-weapon="machinegun" title="Machine Gun">🔥</div>
        </div>
        
        <div id="instructions">
            MOUSE/TOUCH: Aim & Shoot<br>
            1-3: Change Weapon<br>
            Eliminate all enemies!
        </div>
        
        <div id="hud">
            <div class="hud-section">
                <div class="hud-label">HEALTH</div>
                <div id="health-bar">
                    <div id="health-fill" style="width: 100%"></div>
                </div>
            </div>
            
            <div class="hud-section">
                <div class="hud-label">AMMO</div>
                <div id="ammo-display">
                    <div class="hud-value" id="ammo-count">∞</div>
                </div>
            </div>
            
            <div class="hud-section">
                <div class="hud-label">WAVE</div>
                <div class="hud-value" id="wave">1</div>
            </div>
            
            <div class="hud-section">
                <div class="hud-label">ENEMIES</div>
                <div class="hud-value" id="enemies-left">0</div>
            </div>
        </div>
        
        <div id="crosshair">
            <svg width="40" height="40">
                <circle cx="20" cy="20" r="18" fill="none" stroke="#0f0" stroke-width="2" opacity="0.8"/>
                <line x1="20" y1="5" x2="20" y2="35" stroke="#0f0" stroke-width="2"/>
                <line x1="5" y1="20" x2="35" y2="20" stroke="#0f0" stroke-width="2"/>
                <circle cx="20" cy="20" r="3" fill="#f00"/>
            </svg>
        </div>
        
        <div id="gameOver">
            <h1>GAME OVER</h1>
            <div>Final Score: <span id="finalScore">0</span></div>
            <div>Wave Reached: <span id="finalWave">1</span></div>
            <button id="restartBtn">Play Again</button>
        </div>
    </div>

    <!-- Load GameFramework -->
    <script src="/GameFramework/index.js"></script>
    <script>
        // Framework enhancement for better sprite handling
        window.addEventListener('gameframework:ready', () => {
            // Enhance the RenderSystem's drawSpriteFrame method for better error handling
            const originalDrawSpriteFrame = window.RenderSystem.prototype.drawSpriteFrame;
            
            window.RenderSystem.prototype.drawSpriteFrame = function(name, frameIndex, x, y, width, height) {
                const image = this.sprites.get(name);
                const data = this.spriteData.get(name);
                
                if (!image || !data) {
                    console.warn(`Sprite ${name} not found`);
                    return false;
                }
                
                // Ensure frameIndex is valid - clamp to available frames
                const availableFrames = Array.from(data.frames.keys());
                if (availableFrames.length === 0) {
                    console.warn(`No frames available for sprite ${name}`);
                    return false;
                }
                
                // Convert frameIndex to string and validate
                let frameKey = frameIndex.toString();
                
                // If the requested frame doesn't exist, find the closest valid frame
                if (!data.frames.has(frameKey)) {
                    // Try to find a valid frame by checking numeric order
                    const numericFrameIndex = Math.max(0, Math.min(frameIndex, availableFrames.length - 1));
                    
                    // Check if we have numeric indices
                    if (data.frames.has(numericFrameIndex.toString())) {
                        frameKey = numericFrameIndex.toString();
                    } else {
                        // Fallback to first available frame
                        frameKey = availableFrames[0];
                    }
                    
                    // Only warn once per sprite-frame combination to avoid spam
                    const warnKey = `${name}-${frameIndex}`;
                    if (!this._frameWarnings) this._frameWarnings = new Set();
                    if (!this._frameWarnings.has(warnKey)) {
                        console.warn(`Frame ${frameIndex} not found for sprite ${name}, using frame ${frameKey}`);
                        this._frameWarnings.add(warnKey);
                    }
                }
                
                const frame = data.frames.get(frameKey);
                if (!frame) {
                    console.warn(`Frame data missing for ${name}:${frameKey}`);
                    return false;
                }
                
                const drawWidth = width !== undefined ? width : frame.w;
                const drawHeight = height !== undefined ? height : frame.h;
                
                try {
                    this.context.drawImage(
                        image,
                        frame.x, frame.y, frame.w, frame.h,
                        x, y, drawWidth, drawHeight
                    );
                    return true;
                } catch (error) {
                    console.error(`Error drawing sprite ${name}:${frameKey}:`, error);
                    return false;
                }
            };
            
            // Enhance drawSprite method as well
            const originalDrawSprite = window.RenderSystem.prototype.drawSprite;
            
            window.RenderSystem.prototype.drawSprite = function(name, x, y, width, height, frame = 0) {
                const image = this.sprites.get(name);
                if (!image) {
                    console.warn(`Sprite ${name} not found`);
                    return false;
                }
                
                const data = this.spriteData.get(name);
                if (data && data.frames && data.frames.size > 0) {
                    return this.drawSpriteFrame(name, frame, x, y, width, height);
                } else {
                    // Simple image without frame data
                    try {
                        this.context.drawImage(image, x, y, width || image.width, height || image.height);
                        return true;
                    } catch (error) {
                        console.error(`Error drawing simple sprite ${name}:`, error);
                        return false;
                    }
                }
            };
            
            console.log('✅ Enhanced GameFramework sprite rendering for better error handling');
        });
        
        // Wait for GameFramework to load
        let gameInstance = null;
        let spritesLoaded = false;
        
        // Update loading status
        function updateStatus(message) {
            document.getElementById('loadingStatus').textContent = message;
        }
        
        // GameFramework ready handler
        window.addEventListener('gameframework:ready', async () => {
            try {
                updateStatus('Framework loaded! Initializing game...');
                await initializeGame();
            } catch (error) {
                console.error('Failed to initialize game:', error);
                updateStatus('❌ Failed to initialize game');
            }
        });
        
        // GameFramework error handler
        window.addEventListener('gameframework:error', (e) => {
            console.error('GameFramework failed to load:', e.detail.error);
            updateStatus('❌ Failed to load framework');
            document.getElementById('startBtn').textContent = 'Framework Error';
        });
        
        // Initialize the game
        async function initializeGame() {
            try {
                // Create game instance using GameFramework
                gameInstance = await GameFramework.quickStart({
                    width: window.innerWidth,
                    height: window.innerHeight,
                    backgroundColor: '#000000',
                    pixelated: true,
                    debug: false
                });
                
                updateStatus('Loading sprites...');
                
                // Load sprites using GameFramework
                try {
                    updateStatus('Loading Karate Guy sprite...');
                    await gameInstance.loadSprite('karateguy', 'karateguy.json');
                    updateStatus('Karate Guy loaded!');
                    
                    // Verify the sprite was loaded correctly
                    const renderer = gameInstance.getSystem('renderer');
                    const spriteData = renderer.getSpriteData('karateguy');
                    if (spriteData && spriteData.frames.size > 0) {
                        console.log(`✅ Karateguy sprite loaded with ${spriteData.frames.size} frames:`, Array.from(spriteData.frames.keys()));
                    } else {
                        throw new Error('Sprite loaded but no frame data found');
                    }
                } catch (error) {
                    console.warn('❌ Failed to load karateguy sprite, using fallback:', error.message);
                    updateStatus('Creating Karate Guy fallback...');
                    createFallbackSprite(gameInstance, 'karateguy', '#0a0');
                }
                
                try {
                    updateStatus('Loading Ninja sprite...');
                    await gameInstance.loadSprite('ninjamand', 'ninjamand.json');
                    updateStatus('Ninja loaded!');
                    
                    // Verify the sprite was loaded correctly
                    const renderer = gameInstance.getSystem('renderer');
                    const spriteData = renderer.getSpriteData('ninjamand');
                    if (spriteData && spriteData.frames.size > 0) {
                        console.log(`✅ Ninjamand sprite loaded with ${spriteData.frames.size} frames:`, Array.from(spriteData.frames.keys()));
                    } else {
                        throw new Error('Sprite loaded but no frame data found');
                    }
                } catch (error) {
                    console.warn('❌ Failed to load ninjamand sprite, using fallback:', error.message);
                    updateStatus('Creating Ninja fallback...');
                    createFallbackSprite(gameInstance, 'ninjamand', '#808');
                }
                
                spritesLoaded = true;
                updateStatus('All sprites loaded!');
                
                // Initialize the game
                initializeGameSystems();
                
                // Enable start button
                const startBtn = document.getElementById('startBtn');
                startBtn.textContent = 'Start Game';
                startBtn.disabled = false;
                startBtn.addEventListener('click', startGame);
                
                setTimeout(() => {
                    updateStatus('Ready to play!');
                }, 1000);
                
            } catch (error) {
                console.error('Game initialization error:', error);
                updateStatus('❌ Initialization failed');
            }
        }
        
        // Create fallback sprite for missing assets
        function createFallbackSprite(game, name, color) {
            const renderer = game.getSystem('renderer');
            if (renderer) {
                console.log(`Creating fallback sprite for ${name}...`);
                
                // Create a simple canvas-based fallback sprite
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                
                // Draw simple colored square with face
                ctx.fillStyle = color;
                ctx.fillRect(0, 0, 64, 64);
                
                // Add simple face
                ctx.fillStyle = '#f00';
                ctx.fillRect(16, 20, 8, 8); // left eye
                ctx.fillRect(40, 20, 8, 8); // right eye
                ctx.fillRect(24, 40, 16, 4); // mouth
                
                // Store as a basic sprite
                renderer.sprites.set(name, canvas);
                
                // Create comprehensive sprite data with frames that match framework expectations
                const frames = new Map();
                
                // Create 4 identical frames with string keys as expected by framework
                for (let i = 0; i < 4; i++) {
                    const frameKey = i.toString();
                    frames.set(frameKey, {
                        x: 0,
                        y: 0,
                        w: 64,
                        h: 64,
                        duration: 200,
                        sourceSize: { w: 64, h: 64 },
                        spriteSourceSize: { x: 0, y: 0, w: 64, h: 64 }
                    });
                }
                
                const animations = new Map();
                animations.set('idle', {
                    from: 0,
                    to: 3,
                    direction: 'forward',
                    repeat: -1
                });
                
                const spriteData = {
                    frames: frames,
                    animations: animations,
                    image: canvas,
                    meta: { 
                        fallback: true, 
                        frameCount: 4,
                        size: { w: 64, h: 64 },
                        image: canvas
                    }
                };
                
                renderer.spriteData.set(name, spriteData);
                
                console.log(`✅ Created fallback sprite for ${name} with frames:`, Array.from(frames.keys()));
                
                // Verify the sprite was created correctly
                const testSprite = renderer.getSpriteData(name);
                if (testSprite && testSprite.frames.size > 0) {
                    console.log(`✅ Fallback sprite ${name} verified: ${testSprite.frames.size} frames available`);
                    // Test that frame 0 exists
                    if (testSprite.frames.has('0')) {
                        console.log(`✅ Frame 0 exists for ${name}`);
                    } else {
                        console.error(`❌ Frame 0 missing for ${name}`);
                    }
                } else {
                    console.error(`❌ Failed to create fallback sprite data for ${name}`);
                }
            }
        }
        
        // Game variables
        let gameState = {
            score: 0,
            wave: 1,
            playerHealth: 100,
            maxHealth: 100,
            currentWeapon: 'pistol',
            ammo: { shotgun: 50, machinegun: 200 },
            enemies: [],
            bullets: [],
            particles: [],
            powerups: [],
            running: false,
            mouseX: 0,
            mouseY: 0,
            shooting: false,
            fireTimer: 0,
            waveTimer: 0,
            enemiesInWave: 0,
            enemiesKilled: 0,
            shakeX: 0,
            shakeY: 0,
            shakeIntensity: 0
        };
        
        // Weapons configuration
        const weapons = {
            pistol: { damage: 30, fireRate: 3, ammo: Infinity, spread: 0 },
            shotgun: { damage: 20, fireRate: 1, ammo: 50, spread: 0.3, pellets: 5 },
            machinegun: { damage: 15, fireRate: 10, ammo: 200, spread: 0.1 }
        };
        
        // Initialize game systems
        function initializeGameSystems() {
            setupCanvas();
            setupEvents();
        }
        
        function setupCanvas() {
            const canvas = gameInstance.canvas;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        function setupEvents() {
            const canvas = gameInstance.canvas;
            
            // Mouse/touch controls
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                gameState.mouseX = e.clientX - rect.left;
                gameState.mouseY = e.clientY - rect.top;
                updateCrosshair(e.clientX, e.clientY);
            });
            
            canvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                gameState.shooting = true;
            });
            
            canvas.addEventListener('mouseup', () => {
                gameState.shooting = false;
            });
            
            // Touch events
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                gameState.shooting = true;
                handleTouch(e);
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                handleTouch(e);
            });
            
            canvas.addEventListener('touchend', () => {
                gameState.shooting = false;
            });
            
            // Keyboard
            document.addEventListener('keydown', (e) => {
                if (e.key >= '1' && e.key <= '3') {
                    const weaponNames = ['pistol', 'shotgun', 'machinegun'];
                    selectWeapon(weaponNames[parseInt(e.key) - 1]);
                }
            });
            
            // Weapon selection
            document.querySelectorAll('.weapon-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectWeapon(btn.dataset.weapon);
                });
            });
            
            // Restart button
            document.getElementById('restartBtn').addEventListener('click', () => {
                restartGame();
            });
            
            // Resize handling
            window.addEventListener('resize', () => {
                setupCanvas();
            });
            
            // Show crosshair
            document.getElementById('crosshair').style.display = 'block';
        }
        
        function handleTouch(e) {
            const rect = gameInstance.canvas.getBoundingClientRect();
            const touch = e.touches[0];
            gameState.mouseX = touch.clientX - rect.left;
            gameState.mouseY = touch.clientY - rect.top;
            updateCrosshair(touch.clientX, touch.clientY);
        }
        
        function updateCrosshair(clientX, clientY) {
            const crosshair = document.getElementById('crosshair');
            crosshair.style.left = clientX - 20 + 'px';
            crosshair.style.top = clientY - 20 + 'px';
        }
        
        function selectWeapon(weapon) {
            // Check ammo for limited weapons
            if ((weapon === 'shotgun' && gameState.ammo.shotgun <= 0) ||
                (weapon === 'machinegun' && gameState.ammo.machinegun <= 0)) {
                return;
            }
            
            gameState.currentWeapon = weapon;
            
            // Update UI
            document.querySelectorAll('.weapon-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.weapon === weapon);
            });
            
            updateAmmoDisplay();
        }
        
        function updateAmmoDisplay() {
            const ammoCount = document.getElementById('ammo-count');
            if (gameState.currentWeapon === 'pistol') {
                ammoCount.textContent = '∞';
            } else {
                ammoCount.textContent = gameState.ammo[gameState.currentWeapon];
            }
        }
        
        function startGame() {
            if (!spritesLoaded || !gameInstance) {
                console.log('Game not ready yet');
                return;
            }
            
            document.getElementById('startScreen').style.display = 'none';
            gameState.running = true;
            spawnWave();
            gameInstance.start();
            
            // Start custom game loop
            gameLoop();
        }
        
        function restartGame() {
            // Reset game state
            gameState.score = 0;
            gameState.wave = 1;
            gameState.playerHealth = 100;
            gameState.ammo = { shotgun: 50, machinegun: 200 };
            gameState.currentWeapon = 'pistol';
            gameState.enemies = [];
            gameState.bullets = [];
            gameState.particles = [];
            gameState.powerups = [];
            gameState.waveTimer = 0;
            gameState.enemiesInWave = 0;
            gameState.enemiesKilled = 0;
            
            // Clear any existing particles from framework
            const particleSystem = gameInstance.getSystem('particles');
            if (particleSystem && particleSystem.clear) {
                particleSystem.clear();
            }
            
            // Update UI
            updateUI();
            selectWeapon('pistol');
            
            // Hide game over screen
            document.getElementById('gameOver').style.display = 'none';
            
            // Start game
            startGame();
        }
        
        function gameLoop() {
            if (!gameState.running) return;
            
            const deltaTime = 1/60; // Fixed timestep for simplicity
            
            update(deltaTime);
            render();
            
            requestAnimationFrame(gameLoop);
        }
        
        function update(deltaTime) {
            // Update timers
            gameState.fireTimer = Math.max(0, gameState.fireTimer - deltaTime);
            gameState.waveTimer += deltaTime;
            
            // Shooting
            if (gameState.shooting && gameState.fireTimer <= 0) {
                fire();
            }
            
            // Update shake
            if (gameState.shakeIntensity > 0) {
                gameState.shakeX = (Math.random() - 0.5) * gameState.shakeIntensity;
                gameState.shakeY = (Math.random() - 0.5) * gameState.shakeIntensity;
                gameState.shakeIntensity *= 0.9;
                if (gameState.shakeIntensity < 0.5) {
                    gameState.shakeIntensity = 0;
                    gameState.shakeX = 0;
                    gameState.shakeY = 0;
                }
            }
            
            // Update bullets
            gameState.bullets = gameState.bullets.filter(bullet => {
                bullet.x += bullet.vx * deltaTime;
                bullet.y += bullet.vy * deltaTime;
                bullet.z += bullet.vz * deltaTime;
                bullet.life -= deltaTime;
                
                // Check collision with enemies
                for (let enemy of gameState.enemies) {
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    const dz = bullet.z - enemy.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    if (dist < 50) {
                        hitEnemy(enemy, bullet.damage);
                        createHitEffect(bullet.x, bullet.y, bullet.z);
                        return false; // Remove bullet
                    }
                }
                
                return bullet.life > 0 && bullet.z > -1000;
            });
            
            // Update enemies
            gameState.enemies.forEach(enemy => {
                // Move towards player
                enemy.z += enemy.speed * deltaTime;
                enemy.x += Math.sin(enemy.z * 0.01 + enemy.offset) * enemy.sway;
                
                // Update animation with very careful frame bounds
                enemy.animTimer += deltaTime;
                if (enemy.animTimer > 0.2) {
                    enemy.animTimer = 0;
                    
                    // Get current sprite data to ensure we have the right frame count
                    const renderer = gameInstance.getSystem('renderer');
                    const spriteData = renderer?.getSpriteData(enemy.sprite);
                    let maxFrames = 4; // Default fallback
                    
                    if (spriteData && spriteData.frames) {
                        maxFrames = spriteData.frames.size;
                    }
                    
                    // Store the correct max frames on the enemy
                    enemy.maxFrames = maxFrames;
                    
                    // Safely increment frame with bounds checking
                    if (maxFrames > 0) {
                        enemy.animFrame = (enemy.animFrame + 1) % maxFrames;
                    } else {
                        enemy.animFrame = 0;
                    }
                }
                
                // Attack player if close
                if (enemy.z > -100 && !enemy.hasAttacked) {
                    enemy.hasAttacked = true;
                    takeDamage(enemy.damage);
                }
                
                // Update screen position
                updateEnemyScreenPos(enemy);
            });
            
            // Remove enemies that are too close or dead
            gameState.enemies = gameState.enemies.filter(enemy => 
                enemy.health > 0 && enemy.z < 100
            );
            
            // Update particles using framework
            gameInstance.getSystem('particles')?.update(deltaTime);
            
            // Check wave completion
            if (gameState.enemies.length === 0 && gameState.enemiesKilled >= gameState.enemiesInWave && gameState.waveTimer > 3) {
                nextWave();
            }
            
            updateUI();
        }
        
        function render() {
            const renderer = gameInstance.getSystem('renderer');
            if (!renderer) return;
            
            const ctx = gameInstance.context;
            
            // Clear screen
            renderer.clear();
            
            // Apply camera shake
            ctx.save();
            ctx.translate(gameState.shakeX, gameState.shakeY);
            
            drawEnvironment(ctx);
            drawBullets(ctx);
            drawEnemies(ctx, renderer);
            drawPowerups(ctx);
            
            // Render particles using framework
            gameInstance.getSystem('particles')?.render(ctx);
            
            ctx.restore();
        }
        
        function drawEnvironment(ctx) {
            const canvas = gameInstance.canvas;
            
            // Draw starfield/background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            for (let i = 0; i < 50; i++) {
                const x = (Math.sin(performance.now() * 0.001 + i) * 0.5 + 0.5) * canvas.width;
                const y = (Math.cos(performance.now() * 0.001 + i * 0.7) * 0.5 + 0.5) * canvas.height;
                ctx.fillRect(x, y, 2, 2);
            }
            
            // Draw horizon line
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
            
            // Draw perspective grid
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
            ctx.lineWidth = 1;
            
            // Vertical lines with perspective
            for (let x = -10; x <= 10; x++) {
                const screenX = centerX + x * 40;
                const vanishingOffset = x * 15;
                ctx.beginPath();
                ctx.moveTo(screenX, centerY);
                ctx.lineTo(screenX - vanishingOffset, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines for depth
            for (let z = 1; z <= 10; z++) {
                const y = centerY + z * z * 6;
                const alpha = Math.max(0.05, 0.3 - z * 0.03);
                ctx.strokeStyle = `rgba(0, 255, 0, ${alpha})`;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        function drawBullets(ctx) {
            gameState.bullets.forEach(bullet => {
                if (bullet.z >= -50) return;
                
                const fov = 800;
                const scale = fov / -bullet.z;
                const screenX = gameInstance.canvas.width / 2 + bullet.x * scale;
                const screenY = gameInstance.canvas.height / 2 - bullet.y * scale;
                
                ctx.fillStyle = bullet.color;
                ctx.fillRect(screenX - 2, screenY - 2, 4, 4);
            });
        }
        
        function drawEnemies(ctx, renderer) {
            gameState.enemies.forEach(enemy => {
                if (!enemy.visible) return;
                
                const baseSize = 64;
                const size = baseSize * enemy.scale;
                
                // Try to draw sprite using GameFramework renderer
                ctx.save();
                ctx.translate(enemy.screenX, enemy.screenY);
                
                // Check if we have the sprite loaded and validate frame
                const spriteData = renderer.getSpriteData(enemy.sprite);
                const hasSprite = renderer.sprites.has(enemy.sprite) && spriteData;
                
                let spriteDrawn = false;
                if (hasSprite) {
                    // Ensure animFrame is within bounds - be extra careful
                    const availableFrames = Array.from(spriteData.frames.keys());
                    let safeFrame = 0; // Default to frame 0
                    
                    if (availableFrames.length > 0) {
                        if (typeof enemy.animFrame === 'number') {
                            safeFrame = Math.max(0, Math.min(enemy.animFrame, availableFrames.length - 1));
                        }
                        
                        // Double check the frame exists
                        if (!spriteData.frames.has(safeFrame.toString())) {
                            safeFrame = parseInt(availableFrames[0]) || 0;
                        }
                    }
                    
                    // Reset enemy's animFrame to the safe value
                    enemy.animFrame = safeFrame;
                    
                    spriteDrawn = renderer.drawSprite(enemy.sprite, -size/2, -size/2, size, size, safeFrame);
                }
                
                if (!spriteDrawn) {
                    // Fallback to colored rectangle
                    drawEnemyFallback(ctx, enemy, size);
                }
                
                ctx.restore();
                
                // Health bar
                if (enemy.health < enemy.maxHealth) {
                    const barWidth = size;
                    const barHeight = 6;
                    const barY = enemy.screenY - size/2 - 10;
                    
                    ctx.fillStyle = '#333';
                    ctx.fillRect(enemy.screenX - barWidth/2, barY, barWidth, barHeight);
                    
                    ctx.fillStyle = '#f00';
                    const healthPercent = enemy.health / enemy.maxHealth;
                    ctx.fillRect(enemy.screenX - barWidth/2, barY, barWidth * healthPercent, barHeight);
                    
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(enemy.screenX - barWidth/2, barY, barWidth, barHeight);
                }
            });
        }
        
        function drawEnemyFallback(ctx, enemy, size) {
            ctx.fillStyle = enemy.type === 'demon' ? '#f00' : 
                            enemy.type === 'bat' ? '#808' : '#0a0';
            ctx.fillRect(-size/2, -size/2, size, size);
            
            // Eyes
            ctx.fillStyle = '#f00';
            ctx.fillRect(-size/3, -size/4, size/6, size/6);
            ctx.fillRect(size/6, -size/4, size/6, size/6);
            
            // Add simple animation by changing eye size based on animFrame
            const eyeSize = (size/6) * (0.8 + 0.2 * Math.sin(enemy.animFrame));
            ctx.fillRect(-size/3, -size/4, eyeSize, eyeSize);
            ctx.fillRect(size/6, -size/4, eyeSize, eyeSize);
        }
        
        function drawPowerups(ctx) {
            gameState.powerups.forEach(powerup => {
                if (!powerup.visible) return;
                
                const size = 30 * powerup.scale;
                
                ctx.fillStyle = powerup.type === 'health' ? '#0f0' : '#ff0';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                
                if (powerup.type === 'health') {
                    // Cross
                    ctx.fillRect(
                        powerup.screenX - size/2,
                        powerup.screenY - size/6,
                        size,
                        size/3
                    );
                    ctx.fillRect(
                        powerup.screenX - size/6,
                        powerup.screenY - size/2,
                        size/3,
                        size
                    );
                } else {
                    // Box
                    ctx.fillRect(
                        powerup.screenX - size/2,
                        powerup.screenY - size/2,
                        size,
                        size
                    );
                    ctx.strokeRect(
                        powerup.screenX - size/2,
                        powerup.screenY - size/2,
                        size,
                        size
                    );
                }
            });
        }
        
        function fire() {
            const weapon = weapons[gameState.currentWeapon];
            
            // Check ammo
            if (gameState.currentWeapon !== 'pistol' && gameState.ammo[gameState.currentWeapon] <= 0) {
                selectWeapon('pistol');
                return;
            }
            
            gameState.fireTimer = 1 / weapon.fireRate;
            
            // Calculate aim direction
            const aimX = (gameState.mouseX - gameInstance.canvas.width / 2) * 2;
            const aimY = (gameState.mouseY - gameInstance.canvas.height / 2) * 2;
            
            // Fire projectiles
            const pellets = weapon.pellets || 1;
            for (let i = 0; i < pellets; i++) {
                const spread = weapon.spread * (Math.random() - 0.5);
                const bullet = {
                    x: 0, y: 0, z: -100,
                    vx: aimX + spread * 100,
                    vy: aimY + spread * 100,
                    vz: -800,
                    damage: weapon.damage,
                    life: 2,
                    color: gameState.currentWeapon === 'machinegun' ? '#ff0' : '#0f0'
                };
                gameState.bullets.push(bullet);
            }
            
            // Consume ammo
            if (gameState.currentWeapon !== 'pistol') {
                gameState.ammo[gameState.currentWeapon]--;
            }
            
            // Effects
            shake(gameState.currentWeapon === 'shotgun' ? 8 : 3);
            createMuzzleFlash();
        }
        
        function hitEnemy(enemy, damage) {
            enemy.health -= damage;
            
            if (enemy.health <= 0) {
                gameState.score += enemy.score;
                gameState.enemiesKilled++;
                createExplosion(enemy.x, enemy.y, enemy.z);
                
                // Drop powerup chance
                if (Math.random() < 0.3) {
                    dropPowerup(enemy.x, enemy.y, enemy.z);
                }
            }
        }
        
        function takeDamage(amount) {
            gameState.playerHealth -= amount;
            gameState.playerHealth = Math.max(0, gameState.playerHealth);
            shake(15);
            
            if (gameState.playerHealth <= 0) {
                gameOver();
            }
        }
        
        function gameOver() {
            gameState.running = false;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalWave').textContent = gameState.wave;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function spawnWave() {
            gameState.wave++;
            gameState.waveTimer = 0;
            gameState.enemiesKilled = 0;
            gameState.enemiesInWave = Math.min(2 + gameState.wave, 10);
            
            // Spawn enemies over time
            for (let i = 0; i < gameState.enemiesInWave; i++) {
                setTimeout(() => {
                    if (gameState.running) {
                        spawnEnemy();
                    }
                }, i * 1000);
            }
        }
        
        function nextWave() {
            gameState.waveTimer = 0;
            setTimeout(() => {
                if (gameState.running) {
                    spawnWave();
                }
            }, 2000);
        }
        
        function spawnEnemy() {
            const types = [
                { name: 'zombie', sprite: 'karateguy', health: 60, damage: 20, speed: 100, score: 100, flying: false },
                { name: 'demon', sprite: 'karateguy', health: 80, damage: 25, speed: 80, score: 200, flying: false },
                { name: 'bat', sprite: 'ninjamand', health: 40, damage: 15, speed: 200, score: 150, flying: true }
            ];
            
            const type = types[Math.floor(Math.random() * types.length)];
            
            // Get the frame count for this sprite to ensure proper animation bounds
            const renderer = gameInstance.getSystem('renderer');
            const spriteData = renderer?.getSpriteData(type.sprite);
            const maxFrames = spriteData?.frames?.size || 4;
            
            const enemy = {
                type: type.name,
                sprite: type.sprite,
                x: (Math.random() - 0.5) * 800,
                y: type.flying ? -100 - Math.random() * 200 : 0,
                z: -800 - Math.random() * 400,
                health: type.health,
                maxHealth: type.health,
                damage: type.damage,
                speed: type.speed,
                score: type.score,
                flying: type.flying,
                sway: type.flying ? 3 : 1,
                offset: Math.random() * Math.PI * 2,
                hasAttacked: false,
                screenX: 0,
                screenY: 0,
                scale: 1,
                visible: false,
                animFrame: 0, // Always start at frame 0
                animTimer: 0,
                maxFrames: maxFrames // Store for bounds checking
            };
            
            gameState.enemies.push(enemy);
            console.log(`Spawned ${type.name} with sprite ${type.sprite} (${maxFrames} frames)`);
        }
        
        function dropPowerup(x, y, z) {
            const types = ['health', 'ammo_shotgun', 'ammo_machinegun'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            const powerup = {
                type: type,
                x: x,
                y: y,
                z: z,
                baseY: y,
                bobOffset: 0,
                collected: false,
                screenX: 0,
                screenY: 0,
                scale: 1,
                visible: false
            };
            
            gameState.powerups.push(powerup);
        }
        
        function updateEnemyScreenPos(obj) {
            if (obj.z >= -50) {
                obj.visible = false;
                return;
            }
            
            const fov = 800;
            obj.scale = fov / -obj.z;
            obj.screenX = gameInstance.canvas.width / 2 + obj.x * obj.scale;
            obj.screenY = gameInstance.canvas.height / 2 - obj.y * obj.scale;
            
            const margin = 100;
            obj.visible = obj.screenX > -margin && obj.screenX < gameInstance.canvas.width + margin &&
                         obj.screenY > -margin && obj.screenY < gameInstance.canvas.height + margin;
        }
        
        function shake(intensity) {
            gameState.shakeIntensity = intensity;
        }
        
        function createMuzzleFlash() {
            gameInstance.createParticleEffect('sparkle', 
                gameInstance.canvas.width / 2, 
                gameInstance.canvas.height / 2
            );
        }
        
        function createHitEffect(x, y, z) {
            const fov = 800;
            const scale = fov / -z;
            const screenX = gameInstance.canvas.width / 2 + x * scale;
            const screenY = gameInstance.canvas.height / 2 - y * scale;
            
            gameInstance.createParticleEffect('hit', screenX, screenY);
        }
        
        function createExplosion(x, y, z) {
            const fov = 800;
            const scale = fov / -z;
            const screenX = gameInstance.canvas.width / 2 + x * scale;
            const screenY = gameInstance.canvas.height / 2 - y * scale;
            
            gameInstance.createParticleEffect('explosion', screenX, screenY);
        }
        
        function updateUI() {
            document.getElementById('score').textContent = `SCORE: ${gameState.score}`;
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('enemies-left').textContent = Math.max(0, gameState.enemiesInWave - gameState.enemiesKilled);
            document.getElementById('health-fill').style.width = (gameState.playerHealth / gameState.maxHealth * 100) + '%';
            updateAmmoDisplay();
        }
    </script>
</body>
</html>